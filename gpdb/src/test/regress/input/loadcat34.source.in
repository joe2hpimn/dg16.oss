-- -*- mode: sql; -*-
--
-- This file handles the upgrade transformation from 3.3 catalog => 3.4 catalog
--

begin;

-- Disable maintenance of persistent tables until we are done bootstrapping them
set session authorization @gpcurusername@;
set gp_before_persistence_work=true;

-- Copy in the new catalog definitions, bootstrap tables first
copy @gpupgradeschemaname@.pg_class from '@gpupgradedatadir@/upg2_pg_class_toadd33.data' oids null E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_attribute from '@gpupgradedatadir@/upg2_pg_attribute_toadd33.data' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_proc from '@gpupgradedatadir@/upg2_pg_proc_toadd33.data' oids null as E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_type from '@gpupgradedatadir@/upg2_pg_type_toadd33.data' oids null as E'\\N' csv delimiter '|' header;
-- followed by the non-bootstrap tables
copy @gpupgradeschemaname@.pg_index from '@gpupgradedatadir@/upg2_pg_index_toadd33.data' null as E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_namespace from '@gpupgradedatadir@/upg2_pg_namespace_toadd33.data' oids null as E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_description from '@gpupgradedatadir@/upg2_pg_description_toadd33.data' null as E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_depend from '@gpupgradedatadir@/upg2_pg_depend_toadd33.data' null as E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_operator from '@gpupgradedatadir@/upg2_pg_operator_toadd33.data' oids null E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_cast from'@gpupgradedatadir@/upg2_pg_cast_toadd33.data' oids null E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_aggregate from'@gpupgradedatadir@/upg2_pg_aggregate_toadd33.data' null E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_opclass from'@gpupgradedatadir@/upg2_pg_opclass_toadd33.data' oids null E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_amop from'@gpupgradedatadir@/upg2_pg_amop_toadd33.data' null E'\\N' csv delimiter '|' header;
copy @gpupgradeschemaname@.pg_amproc from '@gpupgradedatadir@/upg2_pg_amproc_toadd33.data' null E'\\N' csv delimiter '|' header;

-- plpgsql is now always installed by default.
--
-- We have special hooks around plpgsql to allow the create NOT to error even if the language already exists.
CREATE LANGUAGE plpgsql;


-- fix up pg_tablespace, this is a shared table so the data changes are handled
-- in loadcat34_sh, but the schema changes are stored in pg_class and pg_attribute
-- which aren't shared so we must update the schema in every database.
--
-- We can't simply use an alter statement because that would generate a toast table
-- on a shared table, which is not allowed outside of bootstrap.  So instead we perform
-- the modifications by hand.
--
insert into @gpupgradeschemaname@.pg_attribute values(1213, 'spcfsoid', 26, -1, 4, 7, 0, -1, -1, 't', 'p', 'i', 'f', 'f', 'f', 't', 0);
update @gpupgradeschemaname@.pg_class set relnatts=relnatts+1 where oid='pg_catalog.pg_tablespace'::regclass;

-- fix up pg_appendonly
alter table @gpupgradeschemaname@.pg_appendonly add column columnstore boolean;
alter table @gpupgradeschemaname@.pg_appendonly add column segrelid oid;
alter table @gpupgradeschemaname@.pg_appendonly add column segidxid oid;
alter table @gpupgradeschemaname@.pg_appendonly add column blkdirrelid oid;
alter table @gpupgradeschemaname@.pg_appendonly add column blkdiridxid oid;
alter table @gpupgradeschemaname@.pg_appendonly add column version int4;

-- fill in the new columns based on pg_class
update @gpupgradeschemaname@.pg_appendonly set (columnstore, segrelid, segidxid, blkdirrelid, blkdiridxid) = (a.relstorage='c', a.relaosegrelid, b.relaosegidxid, 0, 0) from @gpupgradeschemaname@.pg_class a left join @gpupgradeschemaname@.pg_class b on (a.relaosegrelid=b.oid) where a.oid=relid;

-- Set default for version
update @gpupgradeschemaname@.pg_appendonly set version = '1';

-- and clear out the now irrelevant entries from pg_class
update @gpupgradeschemaname@.pg_class set relaosegrelid=0, relaosegidxid=0 where relaosegrelid != 0 or relaosegidxid != 0;

-- fix for aocs invalid type
update @gpupgradeschemaname@.pg_attribute set atttypid = 'bytea'::regtype from pg_appendonly where attrelid = segrelid and columnstore and atttypid = 'varbit'::regtype;

-- fix up pg_authid, pg_attribute entries already added in the copy
-- fix the pg_class entry as well.
-- default values will be added in loadcat34_sh
update @gpupgradeschemaname@.pg_class set relnatts=relnatts+3 where oid='pg_catalog.pg_authid'::regclass;

-- fix up pg_partition_rule: we don't go through "alter" since this would create a toast table that doesn't normally exist.
-- new entry already added to pg_attribute in the copy

-- update attribute count in pg_class
update @gpupgradeschemaname@.pg_class set relnatts=14 where oid='pg_catalog.pg_partition_rule'::regclass;

-- fix up pg_exttable: we don't go through "alter" since this would create a toast table that doesn't normally exist.
-- new entry already added to pg_attribute in the copy
-- fix relnatts in pg_class
update @gpupgradeschemaname@.pg_class set relnatts=10 where oid='pg_catalog.pg_exttable'::regclass;
-- set all existing tables to readable external tables
update @gpupgradeschemaname@.pg_exttable set writable='f';
-- update pg_class for external table changes
update @gpupgradeschemaname@.pg_class set relkind='r', relstorage = 'x' where relkind='x' and relstorage='v';

-- fix up pg_partitions view. we update the definition later on in the view section at the bottom
-- but first we must make the necessary adjustments in pg_class and pg_attribute for the 2 new attributes.
-- we can't add them via pg_attribute_toadd because views don't have fixed oids. so do it manually here.
update pg_catalog.pg_class set relnatts=21 where oid=(select c.oid from pg_catalog.pg_class c, pg_namespace n where relname='pg_partitions' and c.relnamespace = n.oid and n.nspname = '@gpupgradeschemaname@');
insert into pg_catalog.pg_attribute select c.oid,'parenttablespace',19,-1,64,20,0,-1,-1,'f','p','i','f','f','f','t',0 from pg_catalog.pg_class c, pg_namespace n where relname='pg_partitions' and c.relnamespace = n.oid and n.nspname = '@gpupgradeschemaname@';
insert into pg_catalog.pg_attribute select c.oid,'partitiontablespace',19,-1,64,21,0,-1,-1,'f','p','i','f','f','f','t',0 from pg_catalog.pg_class c, pg_namespace n where relname='pg_partitions' and c.relnamespace = n.oid and n.nspname = '@gpupgradeschemaname@';

-- fix up pg_roles view. we update the definition later on in the view section at the bottom
-- but first we must make the necessary adjustments in pg_class and pg_attribute for the 3 new attributes.
-- we can't add them via pg_attribute_toadd because views don't have fixed oids. so do it manually here.
update pg_catalog.pg_class set relnatts=16 where oid=(select c.oid from pg_catalog.pg_class c, pg_namespace n where relname='pg_roles' and c.relnamespace = n.oid and n.nspname = '@gpupgradeschemaname@');
insert into pg_catalog.pg_attribute select c.oid,'rolcreaterextgpfd',16,-1,1,14,0,-1,-1,'t','p','c','f','f','f','t',0 from pg_catalog.pg_class c, pg_namespace n where relname='pg_roles' and c.relnamespace = n.oid and n.nspname = '@gpupgradeschemaname@';
insert into pg_catalog.pg_attribute select c.oid,'rolcreaterexthttp',16,-1,1,15,0,-1,-1,'t','p','c','f','f','f','t',0 from pg_catalog.pg_class c, pg_namespace n where relname='pg_roles' and c.relnamespace = n.oid and n.nspname = '@gpupgradeschemaname@';
insert into pg_catalog.pg_attribute select c.oid,'rolcreatewextgpfd',16,-1,1,16,0,-1,-1,'t','p','c','f','f','f','t',0 from pg_catalog.pg_class c, pg_namespace n where relname='pg_roles' and c.relnamespace = n.oid and n.nspname = '@gpupgradeschemaname@';

-- fix up pg_proc and pg_operator to replace "text_pattern_eq" with "texteq"
update @gpupgradeschemaname@.pg_proc set prosrc = 'texteq' where oid = 2162;
update @gpupgradeschemaname@.pg_proc set prosrc = 'texteq' where oid = 2176;
update @gpupgradeschemaname@.pg_proc set prosrc = 'textne' where oid = 2165;
update @gpupgradeschemaname@.pg_proc set prosrc = 'textne' where oid = 2179;
update @gpupgradeschemaname@.pg_operator set oprcode = 'pg_catalog.texteq'::regproc where oid = 2316;
update @gpupgradeschemaname@.pg_operator set oprcode = 'pg_catalog.textne'::regproc where oid = 2319;


-- upgrade views to account for the new Range Table Entry (RTE) Format.
--   ":forceDistRandom" only ever occurs in RTEs and is the last field
--   We missed this upgrade from 32->33 so it occurs here as well, anything that has
--   already been upgraded will not match here because :forceDistRandom will not be
--   last.
--   NOTE: this effects All views, including user views
update @gpupgradeschemaname@.pg_rewrite set ev_action = regexp_replace(ev_action, ':forceDistRandom (true|false)}', E':forceDistRandom \\1 :pseudocols <>}', 'g'), ev_qual = regexp_replace(ev_qual, ':forceDistRandom (true|false)}', E':forceDistRandom \\1 :pseudocols <>}', 'g');

-- upgrade views to account for prepared statement work
CREATE FUNCTION public.gpviewreparse(text) returns text language C as '$libdir/gpupgrade', 'gpviewreparse' STRICT IMMUTABLE NO SQL;
update @gpupgradeschemaname@.pg_rewrite set ev_action = public.gpviewreparse(ev_action), ev_qual = public.gpviewreparse(ev_qual);

-- Reindex normal tables (not shared tables)
reindex table @gpupgradeschemaname@.pg_amproc;
reindex table @gpupgradeschemaname@.pg_attribute;
reindex table @gpupgradeschemaname@.pg_aggregate;
reindex table @gpupgradeschemaname@.pg_appendonly;
reindex table @gpupgradeschemaname@.pg_appendonly_alter_column;
reindex table @gpupgradeschemaname@.pg_class;
reindex table @gpupgradeschemaname@.pg_depend;
reindex table @gpupgradeschemaname@.pg_description;
reindex table @gpupgradeschemaname@.pg_exttable;
reindex table @gpupgradeschemaname@.pg_foreign_data_wrapper;
reindex table @gpupgradeschemaname@.pg_foreign_server;
reindex table @gpupgradeschemaname@.pg_index;
reindex table @gpupgradeschemaname@.pg_namespace;
reindex table @gpupgradeschemaname@.pg_operator;
reindex table @gpupgradeschemaname@.pg_proc;
reindex table @gpupgradeschemaname@.pg_user_mapping;
reindex table @gpupgradeschemaname@.pg_rewrite;
reindex table @gpupgradeschemaname@.pg_stat_last_operation;
reindex table @gpupgradeschemaname@.pg_type;
reindex table @gpupgradeschemaname@.gp_fastsequence;
reindex table @gpupgradeschemaname@.gp_relation_node;

-- Delete the distribution policy from bitmap indexes.
delete from @gpupgradeschemaname@.gp_distribution_policy using pg_catalog.pg_class c, pg_catalog.pg_namespace n where c.relnamespace=n.oid and n.nspname='pg_bitmapindex' and localoid=c.oid;

-- Create new 3.4 views in pg_catalog
set search_path='pg_catalog';
CREATE VIEW @gpupgradeschemaname@.pg_user_mappings AS SELECT U.oid AS umid, S.oid AS srvid, S.srvname AS srvname, U.umuser AS umuser, CASE WHEN U.umuser = 0 THEN 'public' ELSE A.rolname END AS usename, CASE WHEN pg_has_role(S.srvowner, 'USAGE') OR has_server_privilege(S.oid, 'USAGE') THEN U.umoptions ELSE NULL END AS umoptions FROM pg_user_mapping U LEFT JOIN pg_authid A ON (A.oid = U.umuser) JOIN pg_foreign_server S ON (U.umserver = S.oid);
REVOKE ALL on @gpupgradeschemaname@.pg_user_mappings FROM public;

CREATE VIEW @gpupgradeschemaname@.pg_stat_operations AS SELECT  'pg_authid' AS classname,  a.rolname AS objname,  c.objid, NULL AS schemaname, CASE WHEN  ((b.oid = c.stasysid) AND (b.rolname = c.stausename) ) THEN 'CURRENT'  WHEN  (b.rolname != c.stausename) THEN 'CHANGED' ELSE 'DROPPED' END AS usestatus,  CASE WHEN b.rolname IS NULL THEN c.stausename ELSE b.rolname END AS usename,  c.staactionname AS actionname,  c.stasubtype AS subtype, c.statime  FROM  pg_authid a,  (pg_authid b FULL JOIN pg_stat_last_shoperation c ON ((b.oid = c.stasysid))) WHERE ((a.oid = c.objid) AND (c.classid = (SELECT pg_class.oid FROM pg_class WHERE (pg_class.relname = 'pg_authid'::name)))) UNION  SELECT  'pg_class' AS classname,  a.relname AS objname,  c.objid,  N.nspname AS schemaname, CASE WHEN  ((b.oid = c.stasysid) AND (b.rolname = c.stausename) ) THEN 'CURRENT'  WHEN  (b.rolname != c.stausename)  THEN 'CHANGED' ELSE 'DROPPED' END AS usestatus,  CASE WHEN b.rolname IS NULL THEN c.stausename ELSE b.rolname END AS usename,  c.staactionname AS actionname,  c.stasubtype AS subtype, c.statime  FROM pg_class a, pg_namespace n, (pg_authid b FULL JOIN  pg_stat_last_operation c ON ((b.oid = c.stasysid))) WHERE  a.relnamespace = n.oid AND ((a.oid = c.objid) AND (c.classid = (SELECT pg_class.oid FROM pg_class WHERE ((pg_class.relname = 'pg_class'::name) AND (pg_class.relnamespace = (SELECT pg_namespace.oid FROM pg_namespace WHERE (pg_namespace.nspname = 'pg_catalog'::name))))))) UNION SELECT 'pg_namespace' AS classname, a.nspname AS objname,  c.objid,  NULL AS schemaname, CASE WHEN  ((b.oid = c.stasysid) AND (b.rolname = c.stausename) ) THEN 'CURRENT'  WHEN  (b.rolname != c.stausename) THEN 'CHANGED' ELSE 'DROPPED' END AS usestatus,  CASE WHEN b.rolname IS NULL THEN c.stausename ELSE b.rolname END AS usename,  c.staactionname AS actionname,  c.stasubtype AS subtype, c.statime FROM pg_namespace a, (pg_authid b FULL JOIN pg_stat_last_operation c ON ((b.oid = c.stasysid))) WHERE ((a.oid = c.objid) AND (c.classid = (SELECT pg_class.oid FROM pg_class WHERE ((pg_class.relname = 'pg_namespace'::name) AND (pg_class.relnamespace = (SELECT pg_namespace.oid FROM pg_namespace WHERE (pg_namespace.nspname = 'pg_catalog'::name))))))) UNION SELECT 'pg_database' AS classname, a.datname AS objname,  c.objid,  NULL AS schemaname, CASE WHEN  ((b.oid = c.stasysid) AND (b.rolname = c.stausename) ) THEN 'CURRENT'  WHEN  (b.rolname != c.stausename) THEN 'CHANGED' ELSE 'DROPPED' END AS usestatus,  CASE WHEN b.rolname IS NULL THEN c.stausename ELSE b.rolname END AS usename,  c.staactionname AS actionname,  c.stasubtype AS subtype, c.statime FROM pg_database a, (pg_authid b FULL JOIN pg_stat_last_shoperation c ON ((b.oid = c.stasysid))) WHERE ((a.oid = c.objid) AND (c.classid = (SELECT pg_class.oid FROM pg_class WHERE ((pg_class.relname = 'pg_database'::name) AND (pg_class.relnamespace = (SELECT pg_namespace.oid FROM pg_namespace WHERE (pg_namespace.nspname = 'pg_catalog'::name))))))) UNION  SELECT 'pg_filespace' AS classname, a.fsname AS objname,  c.objid,  NULL AS schemaname, CASE WHEN  ((b.oid = c.stasysid) AND (b.rolname = c.stausename) ) THEN 'CURRENT'  WHEN  (b.rolname != c.stausename) THEN 'CHANGED' ELSE 'DROPPED' END AS usestatus,  CASE WHEN b.rolname IS NULL THEN c.stausename ELSE b.rolname END AS usename,  c.staactionname AS actionname,  c.stasubtype AS subtype, c.statime FROM pg_filespace a, (pg_authid b FULL JOIN pg_stat_last_shoperation c ON ((b.oid = c.stasysid))) WHERE ((a.oid = c.objid) AND (c.classid = (SELECT pg_class.oid FROM pg_class WHERE ((pg_class.relname = 'pg_filespace'::name) AND (pg_class.relnamespace = (SELECT pg_namespace.oid FROM pg_namespace WHERE (pg_namespace.nspname = 'pg_catalog'::name))))))) UNION SELECT 'pg_tablespace' AS classname, a.spcname AS objname,  c.objid,  NULL AS schemaname, CASE WHEN  ((b.oid = c.stasysid) AND (b.rolname = c.stausename) ) THEN 'CURRENT'  WHEN  (b.rolname != c.stausename) THEN 'CHANGED' ELSE 'DROPPED' END AS usestatus,  CASE WHEN b.rolname IS NULL THEN c.stausename ELSE b.rolname END AS usename,  c.staactionname AS actionname,  c.stasubtype AS subtype, c.statime FROM pg_tablespace a, (pg_authid b FULL JOIN pg_stat_last_shoperation c ON ((b.oid = c.stasysid))) WHERE ((a.oid = c.objid) AND (c.classid = (SELECT pg_class.oid FROM pg_class WHERE ((pg_class.relname = 'pg_tablespace'::name) AND (pg_class.relnamespace = (SELECT pg_namespace.oid FROM pg_namespace WHERE (pg_namespace.nspname = 'pg_catalog'::name))))))) UNION SELECT 'pg_resqueue' AS classname, a.rsqname as objname, c.objid, NULL AS schemaname, CASE WHEN  ((b.oid = c.stasysid) AND (b.rolname = c.stausename) ) THEN 'CURRENT'  WHEN  (b.rolname != c.stausename) THEN 'CHANGED' ELSE 'DROPPED' END AS usestatus,  CASE WHEN b.rolname IS NULL THEN c.stausename ELSE b.rolname END AS usename,  c.staactionname AS actionname,  c.stasubtype AS subtype, c.statime  FROM pg_resqueue a, (pg_authid b FULL JOIN pg_stat_last_shoperation c ON ((b.oid = c.stasysid))) WHERE ((a.oid = c.objid) AND (c.classid = (SELECT pg_class.oid FROM pg_class WHERE ((pg_class.relname = 'pg_resqueue'::name) AND (pg_class.relnamespace = (SELECT pg_namespace.oid FROM pg_namespace WHERE (pg_namespace.nspname = 'pg_catalog'::name))))))) ORDER BY 9;  
REVOKE ALL ON @gpupgradeschemaname@.pg_stat_operations FROM @gpcurusername@;
GRANT SELECT ON @gpupgradeschemaname@.pg_stat_operations TO public;

CREATE VIEW @gpupgradeschemaname@.pg_stat_partition_operations AS SELECT pso.*, CASE WHEN  pr.parlevel IS NOT NULL  THEN pr.parlevel  ELSE pr2.parlevel END AS partitionlevel, pcns.relname AS parenttablename, pcns.nspname AS parentschemaname, pr.parrelid AS parent_relid FROM (pg_stat_operations pso LEFT OUTER JOIN pg_partition_rule ppr ON pso.objid=ppr.parchildrelid LEFT OUTER JOIN pg_partition pr ON pr.oid = ppr.paroid) LEFT OUTER JOIN  (SELECT MIN(parlevel) AS parlevel, parrelid FROM  pg_partition prx GROUP BY parrelid ) AS pr2 ON pr2.parrelid = pso.objid LEFT OUTER JOIN  ( SELECT pc.oid, * FROM pg_class AS pc FULL JOIN pg_namespace AS ns  ON ns.oid = pc.relnamespace) AS pcns ON pcns.oid = pr.parrelid ;  
REVOKE ALL ON @gpupgradeschemaname@.pg_stat_partition_operations FROM @gpcurusername@;
GRANT SELECT ON @gpupgradeschemaname@.pg_stat_partition_operations TO public;

CREATE VIEW @gpupgradeschemaname@.pg_resqueue_attributes AS SELECT rsqname, 'active_statements' AS resname, rsqcountlimit::text AS ressetting, 1 AS restypid FROM pg_resqueue UNION SELECT rsqname, 'max_cost' AS resname, rsqcostlimit::text AS ressetting, 2 AS restypid FROM pg_resqueue UNION SELECT rsqname, 'cost_overcommit' AS resname, case when rsqovercommit then '1' else '0' end AS ressetting, 4 AS restypid FROM pg_resqueue UNION SELECT rsqname, 'min_cost' AS resname, rsqignorecostlimit::text AS ressetting, 3 AS restypid FROM pg_resqueue UNION SELECT rq.rsqname , rt.resname, rc.ressetting, rt.restypid AS restypid FROM pg_resqueue rq, pg_resourcetype rt, pg_resqueuecapability rc WHERE rq.oid=rc.resqueueid AND rc.restypid = rt.restypid ORDER BY rsqname, restypid ;  
REVOKE ALL ON @gpupgradeschemaname@.pg_resqueue_attributes FROM @gpcurusername@;
GRANT SELECT ON @gpupgradeschemaname@.pg_resqueue_attributes TO public;

-- Create new 3.4 views in information_schema
set search_path='information_schema';

--  Base view for foreign-data-wrappers (no grant)
CREATE VIEW @gpinfoschemaname@._pg_foreign_data_wrappers AS SELECT w.oid, w.fdwowner, w.fdwoptions, CAST(current_database() AS sql_identifier) AS foreign_data_wrapper_catalog, CAST(fdwname AS sql_identifier) AS foreign_data_wrapper_name, CAST(u.rolname AS sql_identifier) AS authorization_identifier, CAST('c' AS character_data) AS foreign_data_wrapper_language FROM pg_foreign_data_wrapper w, pg_authid u WHERE u.oid = w.fdwowner AND (pg_has_role(fdwowner, 'USAGE') OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE'));

-- Foreign-data-wrapper-options
CREATE VIEW @gpinfoschemaname@.foreign_data_wrapper_options AS SELECT foreign_data_wrapper_catalog, foreign_data_wrapper_name, CAST((pg_options_to_table(w.fdwoptions)).option_name AS sql_identifier) AS option_name, CAST((pg_options_to_table(w.fdwoptions)).option_value AS character_data) AS option_value FROM _pg_foreign_data_wrappers w;
GRANT SELECT ON @gpinfoschemaname@.foreign_data_wrapper_options TO PUBLIC;

-- Foreign-data-wrappers
CREATE VIEW @gpinfoschemaname@.foreign_data_wrappers AS SELECT foreign_data_wrapper_catalog, foreign_data_wrapper_name, authorization_identifier, CAST(NULL AS character_data) AS library_name, foreign_data_wrapper_language FROM _pg_foreign_data_wrappers w;
GRANT SELECT ON @gpinfoschemaname@.foreign_data_wrappers TO PUBLIC;

-- Base view for foreign-servers (no grant)
CREATE VIEW @gpinfoschemaname@._pg_foreign_servers AS SELECT s.oid, s.srvoptions, CAST(current_database() AS sql_identifier) AS foreign_server_catalog, CAST(srvname AS sql_identifier) AS foreign_server_name, CAST(current_database() AS sql_identifier) AS foreign_data_wrapper_catalog, CAST(w.fdwname AS sql_identifier) AS foreign_data_wrapper_name, CAST(srvtype AS character_data) AS foreign_server_type, CAST(srvversion AS character_data) AS foreign_server_version, CAST(u.rolname AS sql_identifier) AS authorization_identifier FROM pg_foreign_server s, pg_foreign_data_wrapper w, pg_authid u WHERE w.oid = s.srvfdw AND u.oid = s.srvowner AND (pg_has_role(s.srvowner, 'USAGE') OR has_server_privilege(s.oid, 'USAGE'));

-- Foreign-server-options
CREATE VIEW @gpinfoschemaname@.foreign_server_options AS SELECT foreign_server_catalog, foreign_server_name, CAST((pg_options_to_table(s.srvoptions)).option_name AS sql_identifier) AS option_name, CAST((pg_options_to_table(s.srvoptions)).option_value AS character_data) AS option_value FROM _pg_foreign_servers s;
GRANT SELECT ON TABLE @gpinfoschemaname@.foreign_server_options TO PUBLIC;

-- Foreign-servers
CREATE VIEW @gpinfoschemaname@.foreign_servers AS SELECT foreign_server_catalog, foreign_server_name, foreign_data_wrapper_catalog, foreign_data_wrapper_name, foreign_server_type, foreign_server_version, authorization_identifier FROM _pg_foreign_servers;
GRANT SELECT ON @gpinfoschemaname@.foreign_servers TO PUBLIC;

-- Base view for user-mappings
CREATE VIEW @gpinfoschemaname@._pg_user_mappings AS SELECT um.oid, um.umoptions, um.umuser, CAST(COALESCE(u.rolname,'PUBLIC') AS sql_identifier ) AS authorization_identifier, s.foreign_server_catalog, s.foreign_server_name, s.authorization_identifier AS srvowner FROM pg_user_mapping um LEFT JOIN pg_authid u ON (u.oid = um.umuser), @gpinfoschemaname@._pg_foreign_servers s WHERE s.oid = um.umserver;

-- user_mapping_options
CREATE VIEW @gpinfoschemaname@.user_mapping_options AS SELECT authorization_identifier, foreign_server_catalog, foreign_server_name, CAST((pg_options_to_table(um.umoptions)).option_name AS sql_identifier) AS option_name, CAST(CASE WHEN (umuser <> 0 AND authorization_identifier = current_user) OR (umuser = 0 AND pg_has_role(srvowner, 'USAGE')) OR (SELECT rolsuper FROM pg_authid WHERE rolname = current_user) THEN (pg_options_to_table(um.umoptions)).option_value ELSE NULL END AS character_data) AS option_value FROM @gpinfoschemaname@._pg_user_mappings um;
GRANT SELECT ON @gpinfoschemaname@.user_mapping_options TO PUBLIC;

-- user_mappings
CREATE VIEW @gpinfoschemaname@.user_mappings AS SELECT authorization_identifier, foreign_server_catalog, foreign_server_name FROM _pg_user_mappings;
REVOKE ALL ON @gpinfoschemaname@.user_mappings FROM @gpcurusername@;
GRANT SELECT ON @gpinfoschemaname@.user_mappings TO PUBLIC;

-- 
-- Modifying existing catalog views is more complicated than creating new views.
-- To handle this we create a new view with the new definition then update the old
-- entry in pg_rewrite to match the new definition.
--
-- NOTE: this is not a safe thing to do for every change that shows up in view definitions.
--   * Views can NOT change the row descriptor returned from the view
--   * This should not be used for structural changes to parse trees that are not due to 
--     changed view definitions.
--
-- We use this function when updating catalog views.  It copys the view 
-- contents from a source view into a target view, this is more than just
-- a simple text exchange of pg_rewrite because the parsenode contains
-- range table entries to the owning view that must be fixed when cloning
-- the view definition.  Additionally we perform validations that the 
-- source and target view are compatible and do not change the record type
-- of the underlying view.
CREATE FUNCTION public.gpviewcopy(oid, oid) returns void language C as '$libdir/gpupgrade', 'gpviewcopy' STRICT IMMUTABLE NO SQL;

-- Update modified views in pg_catalog
set search_path='pg_catalog';

-- pg_catalog.pg_partitions
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS select schemaname, tablename, partitionschemaname, partitiontablename, partitionname, parentpartitiontablename, parentpartitionname, partitiontype, partitionlevel, case when partitiontype <> 'range'::text then null::bigint when partitionnodefault > 0 then partitionrank when partitionrank = 0 then null::bigint else partitionrank end as partitionrank, partitionposition, partitionlistvalues, partitionrangestart, case when partitiontype = 'range'::text then partitionstartinclusive else null::boolean end as partitionstartinclusive, partitionrangeend, case when partitiontype = 'range'::text then partitionendinclusive else null::boolean end as partitionendinclusive, partitioneveryclause, parisdefault as partitionisdefault, partitionboundary, parentspace as parenttablespace, partspace as partitiontablespace from ( select n.nspname as schemaname, cl.relname as tablename, n2.nspname as partitionschemaname, cl2.relname as partitiontablename, pr1.parname as partitionname, cl3.relname as parentpartitiontablename, pr2.parname as parentpartitionname, case when pp.parkind = 'h'::"char" then 'hash'::text when pp.parkind = 'r'::"char" then 'range'::text when pp.parkind = 'l'::"char" then 'list'::text else null::text end as partitiontype, pp.parlevel as partitionlevel, pr1.parruleord as partitionposition, case when pp.parkind != 'r'::"char" or pr1.parisdefault then null::bigint else rank() over( partition by pp.oid, cl.relname, pp.parlevel, cl3.relname order by pr1.parisdefault, pr1.parruleord) end as partitionrank, pg_get_expr(pr1.parlistvalues, pr1.parchildrelid) as partitionlistvalues, pg_get_expr(pr1.parrangestart, pr1.parchildrelid) as partitionrangestart, pr1.parrangestartincl as partitionstartinclusive, pg_get_expr(pr1.parrangeend, pr1.parchildrelid) as partitionrangeend, pr1.parrangeendincl as partitionendinclusive, pg_get_expr(pr1.parrangeevery, pr1.parchildrelid) as partitioneveryclause, min(pr1.parruleord) over( partition by pp.oid, cl.relname, pp.parlevel, cl3.relname order by pr1.parruleord) as partitionnodefault, pr1.parisdefault, pg_get_partition_rule_def(pr1.oid, true) as partitionboundary, coalesce(sp.spcname, dfltspcname) as parentspace, coalesce(sp3.spcname, dfltspcname) as partspace from pg_namespace n, pg_namespace n2, pg_class cl left join pg_tablespace sp on cl.reltablespace = sp.oid, pg_class cl2, pg_partition pp, pg_partition_rule pr1 left join pg_partition_rule pr2 on pr1.parparentrule = pr2.oid left join pg_class cl3 on pr2.parchildrelid = cl3.oid left join pg_tablespace sp3 on cl3.reltablespace = sp3.oid, (select s.spcname from pg_database, pg_tablespace s where datname = current_database() and dattablespace = s.oid) d(dfltspcname) where pp.paristemplate = false and pp.parrelid = cl.oid and pr1.paroid = pp.oid and cl2.oid = pr1.parchildrelid and cl.relnamespace = n.oid and cl2.relnamespace = n2.oid) p1;

SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpupgradeschemaname@.pg_partitions'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- pg_catalog.pg_roles
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS select rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcatupdate, rolcanlogin, rolconnlimit, '********'::text as rolpassword, rolvaliduntil, rolconfig, rolresqueue, oid, rolcreaterextgpfd, rolcreaterexthttp, rolcreatewextgpfd FROM pg_authid;

SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpupgradeschemaname@.pg_roles'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- pg_catalog.pg_partition_templates
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS select schemaname, tablename, partitionname, partitiontype, partitionlevel, case when (partitiontype != 'range') then NULL when (partitionnodefault > 0) then partitionrank when (partitionrank = 1) then NULL else  partitionrank - 1 end as partitionrank, partitionposition, partitionlistvalues, partitionrangestart, case when (partitiontype = 'range') then partitionstartinclusive else NULL end as partitionstartinclusive, partitionrangeend, case when (partitiontype = 'range') then partitionendinclusive else NULL end as partitionendinclusive, partitioneveryclause, parisdefault as partitionisdefault, partitionboundary from ( select n.nspname as schemaname, cl.relname as tablename, pr1.parname as partitionname, p.parlevel as partitionlevel, pr1.parruleord as partitionposition, rank() over (partition by p.oid, cl.relname, p.parlevel order by pr1.parruleord) as partitionrank, pg_get_expr(pr1.parlistvalues, p.parrelid) as partitionlistvalues, pg_get_expr(pr1.parrangestart, p.parrelid) as partitionrangestart, pr1.parrangestartincl as partitionstartinclusive, pg_get_expr(pr1.parrangeend, p.parrelid) as partitionrangeend, pr1.parrangeendincl as partitionendinclusive, pg_get_expr(pr1.parrangeevery, p.parrelid) as partitioneveryclause, min(pr1.parruleord) over (partition by p.oid, cl.relname, p.parlevel order by pr1.parruleord) as partitionnodefault, pr1.parisdefault, case when p.parkind = 'h' then 'hash' when p.parkind = 'r' then 'range' when p.parkind = 'l' then 'list' else null end as partitiontype, pg_get_partition_rule_def(pr1.oid, true) as partitionboundary from pg_namespace n, pg_class cl, pg_partition p, pg_partition_rule pr1 where p.parrelid = cl.oid and pr1.paroid = p.oid and cl.relnamespace = n.oid and p.paristemplate = 't'  ) p1;
SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpupgradeschemaname@.pg_partition_templates'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- Update modified views in information_schema
set search_path='information_schema';

-- information_schema.check_constraints
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS SELECT CAST(current_database() AS sql_identifier) AS constraint_catalog, CAST(rs.nspname AS sql_identifier) AS constraint_schema, CAST(con.conname AS sql_identifier) AS constraint_name, CAST(substring(pg_get_constraintdef(con.oid) from 7) AS character_data) AS check_clause FROM pg_constraint con LEFT OUTER JOIN pg_namespace rs ON (rs.oid = con.connamespace) LEFT OUTER JOIN pg_class c ON (c.oid = con.conrelid) LEFT OUTER JOIN pg_type t ON (t.oid = con.contypid) WHERE pg_has_role(coalesce(c.relowner, t.typowner), 'USAGE') AND con.contype = 'c' UNION SELECT CAST(current_database() AS sql_identifier) AS constraint_catalog, CAST(n.nspname AS sql_identifier) AS constraint_schema, CAST(CAST(n.oid AS text) || '_' || CAST(r.oid AS text) || '_' || CAST(a.attnum AS text) || '_not_null' AS sql_identifier) AS constraint_name, CAST(a.attname || ' IS NOT NULL' AS character_data) AS check_clause FROM pg_namespace n, pg_class r, pg_attribute a WHERE n.oid = r.relnamespace AND r.oid = a.attrelid AND a.attnum > 0 AND NOT a.attisdropped AND a.attnotnull AND r.relkind = 'r' AND pg_has_role(r.relowner, 'USAGE');
SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpinfoschemaname@.check_constraints'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- information_schema.parameters
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS SELECT CAST(current_database() AS sql_identifier) AS specific_catalog, CAST(n_nspname AS sql_identifier) AS specific_schema, CAST(proname || '_' || CAST(p_oid AS text) AS sql_identifier) AS specific_name, CAST((ss.x).n AS cardinal_number) AS ordinal_position, CAST( CASE WHEN proargmodes IS NULL THEN 'IN' WHEN proargmodes[(ss.x).n] = 'i' THEN 'IN' WHEN proargmodes[(ss.x).n] = 'o' THEN 'OUT' WHEN proargmodes[(ss.x).n] = 'b' THEN 'INOUT' WHEN proargmodes[(ss.x).n] = 'v' THEN 'IN' WHEN proargmodes[(ss.x).n] = 't' THEN 'OUT' END AS character_data) AS parameter_mode, CAST('NO' AS character_data) AS is_result, CAST('NO' AS character_data) AS as_locator, CAST(NULLIF(proargnames[(ss.x).n], '') AS sql_identifier) AS parameter_name, CAST( CASE WHEN t.typelem <> 0 AND t.typlen = -1 THEN 'ARRAY' WHEN nt.nspname = 'pg_catalog' THEN format_type(t.oid, null) ELSE 'USER-DEFINED' END AS character_data) AS data_type, CAST(null AS cardinal_number) AS character_maximum_length, CAST(null AS cardinal_number) AS character_octet_length, CAST(null AS sql_identifier) AS character_set_catalog, CAST(null AS sql_identifier) AS character_set_schema, CAST(null AS sql_identifier) AS character_set_name, CAST(null AS sql_identifier) AS collation_catalog, CAST(null AS sql_identifier) AS collation_schema, CAST(null AS sql_identifier) AS collation_name, CAST(null AS cardinal_number) AS numeric_precision, CAST(null AS cardinal_number) AS numeric_precision_radix, CAST(null AS cardinal_number) AS numeric_scale, CAST(null AS cardinal_number) AS datetime_precision, CAST(null AS character_data) AS interval_type, CAST(null AS character_data) AS interval_precision, CAST(current_database() AS sql_identifier) AS udt_catalog, CAST(nt.nspname AS sql_identifier) AS udt_schema, CAST(t.typname AS sql_identifier) AS udt_name, CAST(null AS sql_identifier) AS scope_catalog, CAST(null AS sql_identifier) AS scope_schema, CAST(null AS sql_identifier) AS scope_name, CAST(null AS cardinal_number) AS maximum_cardinality, CAST((ss.x).n AS sql_identifier) AS dtd_identifier FROM pg_type t, pg_namespace nt, ( SELECT n.nspname AS n_nspname, p.proname, p.oid AS p_oid, p.proargnames, p.proargmodes, _pg_expandarray(coalesce(p.proallargtypes, p.proargtypes::oid[])) AS x FROM pg_namespace n, pg_proc p WHERE n.oid = p.pronamespace AND (pg_has_role(p.proowner, 'USAGE') OR has_function_privilege(p.oid, 'EXECUTE'))) AS ss WHERE t.oid = (ss.x).x AND t.typnamespace = nt.oid;
SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpinfoschemaname@.parameters'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- information_schema.element_types
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS SELECT CAST(current_database() AS sql_identifier) AS object_catalog, CAST(n.nspname AS sql_identifier) AS object_schema, CAST(x.objname AS sql_identifier) AS object_name, CAST(x.objtype AS character_data) AS object_type, CAST(x.objdtdid AS sql_identifier) AS collection_type_identifier, CAST( CASE WHEN nbt.nspname = 'pg_catalog' THEN format_type(bt.oid, null) ELSE 'USER-DEFINED' END AS character_data) AS data_type, CAST(null AS cardinal_number) AS character_maximum_length, CAST(null AS cardinal_number) AS character_octet_length, CAST(null AS sql_identifier) AS character_set_catalog, CAST(null AS sql_identifier) AS character_set_schema, CAST(null AS sql_identifier) AS character_set_name, CAST(null AS sql_identifier) AS collation_catalog, CAST(null AS sql_identifier) AS collation_schema, CAST(null AS sql_identifier) AS collation_name, CAST(null AS cardinal_number) AS numeric_precision, CAST(null AS cardinal_number) AS numeric_precision_radix, CAST(null AS cardinal_number) AS numeric_scale, CAST(null AS cardinal_number) AS datetime_precision, CAST(null AS character_data) AS interval_type, CAST(null AS character_data) AS interval_precision, CAST(null AS character_data) AS domain_default, CAST(current_database() AS sql_identifier) AS udt_catalog, CAST(nbt.nspname AS sql_identifier) AS udt_schema, CAST(bt.typname AS sql_identifier) AS udt_name, CAST(null AS sql_identifier) AS scope_catalog, CAST(null AS sql_identifier) AS scope_schema, CAST(null AS sql_identifier) AS scope_name, CAST(null AS cardinal_number) AS maximum_cardinality, CAST('a' || CAST(x.objdtdid AS text) AS sql_identifier) AS dtd_identifier FROM pg_namespace n, pg_type at, pg_namespace nbt, pg_type bt, ( SELECT c.relnamespace, CAST(c.relname AS sql_identifier), 'TABLE'::text, a.attnum, a.atttypid FROM pg_class c, pg_attribute a WHERE c.oid = a.attrelid AND c.relkind IN ('r', 'v') AND attnum > 0 AND NOT attisdropped UNION ALL SELECT t.typnamespace, CAST(t.typname AS sql_identifier), 'DOMAIN'::text, 1, t.typbasetype FROM pg_type t WHERE t.typtype = 'd' UNION ALL SELECT pronamespace, CAST(proname || '_' || CAST(oid AS text) AS sql_identifier), 'ROUTINE'::text, (ss.x).n, (ss.x).x FROM (SELECT p.pronamespace, p.proname, p.oid, _pg_expandarray(coalesce(p.proallargtypes, p.proargtypes::oid[])) AS x FROM pg_proc p) AS ss UNION ALL SELECT p.pronamespace, CAST(p.proname || '_' || CAST(p.oid AS text) AS sql_identifier), 'ROUTINE'::text, 0, p.prorettype FROM pg_proc p) AS x (objschema, objname, objtype, objdtdid, objtypeid) WHERE n.oid = x.objschema AND at.oid = x.objtypeid AND (at.typelem <> 0 AND at.typlen = -1) AND at.typelem = bt.oid AND nbt.oid = bt.typnamespace AND (n.nspname, x.objname, x.objtype, CAST(x.objdtdid AS sql_identifier)) IN ( SELECT object_schema, object_name, object_type, dtd_identifier FROM data_type_privileges );
SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpinfoschemaname@.element_types'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- information_schema.role_usage_grants
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS SELECT CAST(grantor AS sql_identifier), CAST(grantee AS sql_identifier), CAST(object_catalog AS sql_identifier), CAST(object_schema AS sql_identifier), CAST(object_name AS sql_identifier), CAST(object_type as character_data), CAST(privilege_type as character_data), CAST(is_grantable as character_data) FROM (SELECT u_grantor.rolname AS grantor, g_grantee.rolname AS grantee, current_database() AS object_catalog, '' AS object_schema, fdw.fdwname AS object_name, 'FOREIGN DATA WRAPPER' AS object_type, 'USAGE' AS privilege_type, CASE WHEN pg_has_role(g_grantee.oid, fdw.fdwowner, 'USAGE') OR aclcontains(fdw.fdwacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'USAGE', true)) THEN 'YES' ELSE 'NO' END AS is_grantable FROM pg_foreign_data_wrapper fdw, pg_authid u_grantor, pg_authid g_grantee WHERE aclcontains(fdw.fdwacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'USAGE', false)) AND (u_grantor.rolname IN (SELECT role_name FROM enabled_roles) OR g_grantee.rolname IN (SELECT role_name FROM enabled_roles)) UNION ALL SELECT u_grantor.rolname AS grantor, g_grantee.rolname AS grantee, current_database() AS object_catalog, '' AS object_schema, srv.srvname AS object_name, 'FOREIGN SERVER' AS object_type, 'USAGE' AS privilege_type, CASE WHEN pg_has_role(g_grantee.oid, srv.srvowner, 'USAGE') OR aclcontains(srv.srvacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'USAGE', true)) THEN 'YES' ELSE 'NO' END AS is_grantable FROM pg_foreign_server srv, pg_authid u_grantor, pg_authid g_grantee WHERE aclcontains(srv.srvacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'USAGE', false)) AND (u_grantor.rolname IN (SELECT role_name FROM enabled_roles) OR g_grantee.rolname IN (SELECT role_name FROM enabled_roles))) subquery;
SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpinfoschemaname@.role_usage_grants'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- information_schema.tables
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS SELECT CAST(current_database() AS sql_identifier) AS table_catalog, CAST(nc.nspname AS sql_identifier) AS table_schema, CAST(c.relname AS sql_identifier) AS table_name, CAST( CASE WHEN nc.oid = pg_my_temp_schema() THEN 'LOCAL TEMPORARY' WHEN c.relkind = 'r' THEN 'BASE TABLE' WHEN c.relkind = 'v' THEN 'VIEW' ELSE null END AS character_data) AS table_type, CAST(null AS sql_identifier) AS self_referencing_column_name, CAST(null AS character_data) AS reference_generation, CAST(null AS sql_identifier) AS user_defined_type_catalog, CAST(null AS sql_identifier) AS user_defined_type_schema, CAST(null AS sql_identifier) AS user_defined_type_name, CAST(CASE WHEN (c.relkind != 'r' OR (nc.nspname = 'pg_catalog' AND (c.relname LIKE 'gp_persistent_%' OR c.relname = 'gp_global_sequence')) OR c.relstorage = 'f' OR (c.relstorage = 'x' AND x.writable = 'f')) THEN 'NO' ELSE 'YES' END AS character_data) AS is_insertable_into, CAST('NO' AS character_data) AS is_typed, CAST( CASE WHEN nc.oid = pg_my_temp_schema() THEN 'PRESERVE' ELSE null END AS character_data) AS commit_action FROM pg_class c LEFT OUTER JOIN pg_exttable x ON c.oid = x.reloid, pg_namespace nc WHERE c.relnamespace = nc.oid AND c.relkind IN ('r', 'v') AND (NOT pg_is_other_temp_schema(nc.oid)) AND (pg_has_role(c.relowner, 'USAGE') OR has_table_privilege(c.oid, 'SELECT') OR has_table_privilege(c.oid, 'INSERT') OR has_table_privilege(c.oid, 'UPDATE') OR has_table_privilege(c.oid, 'DELETE') OR has_table_privilege(c.oid, 'REFERENCES') OR has_table_privilege(c.oid, 'TRIGGER') );
SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpinfoschemaname@.tables'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- Add the new pg_depend entry:
--    information_schema.role_usage_grants -> information_schema.enabled_roles
--  It would be nice to roll this into the gpviewcopy() logic.
INSERT INTO @gpupgradeschemaname@.pg_depend SELECT 'pg_catalog.pg_rewrite'::regclass::oid, oid, 0, 'pg_catalog.pg_class'::regclass::oid, 'information_schema.enabled_roles'::regclass::oid, 1, 'n' from pg_catalog.pg_rewrite where ev_class='information_schema.role_usage_grants'::regclass and rulename='_RETURN';


-- information_schema.table_constraints
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS SELECT CAST(current_database() AS sql_identifier) AS constraint_catalog, CAST(nc.nspname AS sql_identifier) AS constraint_schema, CAST(c.conname AS sql_identifier) AS constraint_name, CAST(current_database() AS sql_identifier) AS table_catalog, CAST(nr.nspname AS sql_identifier) AS table_schema, CAST(r.relname AS sql_identifier) AS table_name, CAST( CASE c.contype WHEN 'c' THEN 'CHECK' WHEN 'f' THEN 'FOREIGN KEY' WHEN 'p' THEN 'PRIMARY KEY' WHEN 'u' THEN 'UNIQUE' END AS character_data) AS constraint_type, CAST(CASE WHEN c.condeferrable THEN 'YES' ELSE 'NO' END AS character_data) AS is_deferrable, CAST(CASE WHEN c.condeferred THEN 'YES' ELSE 'NO' END AS character_data) AS initially_deferred FROM pg_namespace nc, pg_namespace nr, pg_constraint c, pg_class r WHERE nc.oid = c.connamespace AND nr.oid = r.relnamespace AND c.conrelid = r.oid AND r.relkind = 'r' AND (NOT pg_is_other_temp_schema(nr.oid)) AND (pg_has_role(r.relowner, 'USAGE') OR has_table_privilege(r.oid, 'INSERT') OR has_table_privilege(r.oid, 'UPDATE') OR has_table_privilege(r.oid, 'DELETE') OR has_table_privilege(r.oid, 'REFERENCES') OR has_table_privilege(r.oid, 'TRIGGER') ) UNION SELECT CAST(current_database() AS sql_identifier) AS constraint_catalog, CAST(nr.nspname AS sql_identifier) AS constraint_schema, CAST(CAST(nr.oid AS text) || '_' || CAST(r.oid AS text) || '_' || CAST(a.attnum AS text) || '_not_null' AS sql_identifier) AS constraint_name, CAST(current_database() AS sql_identifier) AS table_catalog, CAST(nr.nspname AS sql_identifier) AS table_schema, CAST(r.relname AS sql_identifier) AS table_name, CAST('CHECK' AS character_data) AS constraint_type, CAST('NO' AS character_data) AS is_deferrable, CAST('NO' AS character_data) AS initially_deferred FROM pg_namespace nr, pg_class r, pg_attribute a WHERE nr.oid = r.relnamespace AND r.oid = a.attrelid AND a.attnotnull AND a.attnum > 0 AND NOT a.attisdropped AND r.relkind = 'r' AND (NOT pg_is_other_temp_schema(nr.oid)) AND (pg_has_role(r.relowner, 'USAGE') OR has_table_privilege(r.oid, 'INSERT') OR has_table_privilege(r.oid, 'UPDATE') OR has_table_privilege(r.oid, 'DELETE') OR has_table_privilege(r.oid, 'REFERENCES') OR has_table_privilege(r.oid, 'TRIGGER') ); 
SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpinfoschemaname@.table_constraints'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- information_schema.usage_privileges
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS SELECT CAST(grantor AS sql_identifier), CAST(grantee AS sql_identifier), CAST(object_catalog AS sql_identifier), CAST(object_schema AS sql_identifier), CAST(object_name AS sql_identifier), CAST(object_type as character_data), CAST(privilege_type as character_data), CAST(is_grantable as character_data) FROM (SELECT u.rolname AS grantor, 'PUBLIC' AS grantee, current_database() AS object_catalog, n.nspname AS object_schema, t.typname AS object_name, 'DOMAIN' AS object_type, 'USAGE' AS privilege_type, 'NO' AS is_grantable FROM pg_authid u, pg_namespace n, pg_type t WHERE u.oid = t.typowner AND t.typnamespace = n.oid AND t.typtype = 'd' UNION ALL SELECT u_grantor.rolname AS grantor, grantee.rolname AS grantee, current_database() AS object_catalog, '' AS object_schema, fdw.fdwname AS object_name, 'FOREIGN DATA WRAPPER' AS object_type, 'USAGE' AS privilege_type, CASE WHEN pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE') OR aclcontains(fdw.fdwacl, makeaclitem(grantee.oid, u_grantor.oid, 'USAGE', true)) THEN 'YES' ELSE 'NO' END AS is_grantable FROM pg_foreign_data_wrapper fdw, pg_authid u_grantor, ( SELECT oid, rolname FROM pg_authid UNION ALL SELECT 0::oid, 'PUBLIC' ) AS grantee (oid, rolname) WHERE aclcontains(fdw.fdwacl, makeaclitem(grantee.oid, u_grantor.oid, 'USAGE', false)) AND (pg_has_role(u_grantor.oid, 'USAGE') OR pg_has_role(grantee.oid, 'USAGE') OR grantee.rolname = 'PUBLIC') UNION ALL SELECT u_grantor.rolname AS grantor, grantee.rolname AS grantee, current_database() AS object_catalog, '' AS object_schema, srv.srvname AS object_name, 'FOREIGN SERVER' AS object_type, 'USAGE' AS privilege_type, CASE WHEN pg_has_role(grantee.oid, srv.srvowner, 'USAGE') OR aclcontains(srv.srvacl, makeaclitem(grantee.oid, u_grantor.oid, 'USAGE', true)) THEN 'YES' ELSE 'NO' END AS is_grantable FROM pg_foreign_server srv, pg_authid u_grantor, ( SELECT oid, rolname FROM pg_authid UNION ALL SELECT 0::oid, 'PUBLIC' ) AS grantee (oid, rolname) WHERE aclcontains(srv.srvacl, makeaclitem(grantee.oid, u_grantor.oid, 'USAGE', false)) AND (pg_has_role(u_grantor.oid, 'USAGE') OR pg_has_role(grantee.oid, 'USAGE') OR grantee.rolname = 'PUBLIC') ) subquery;
SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpinfoschemaname@.usage_privileges'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- information_schema.views
CREATE VIEW @gpupgradeschemaname@.gp_migrator_staging_view AS SELECT CAST(current_database() AS sql_identifier) AS table_catalog, CAST(nc.nspname AS sql_identifier) AS table_schema, CAST(c.relname AS sql_identifier) AS table_name, CAST( CASE WHEN pg_has_role(c.relowner, 'USAGE') THEN pg_get_viewdef(c.oid) ELSE null END AS character_data) AS view_definition, CAST('NONE' AS character_data) AS check_option, CAST( CASE WHEN EXISTS (SELECT 1 FROM pg_rewrite WHERE ev_class = c.oid AND ev_type = '2' AND is_instead) AND EXISTS (SELECT 1 FROM pg_rewrite WHERE ev_class = c.oid AND ev_type = '4' AND is_instead) THEN 'YES' ELSE 'NO' END AS character_data) AS is_updatable, CAST( CASE WHEN EXISTS (SELECT 1 FROM pg_rewrite WHERE ev_class = c.oid AND ev_type = '3' AND is_instead) THEN 'YES' ELSE 'NO' END AS character_data) AS is_insertable_into FROM pg_namespace nc, pg_class c WHERE c.relnamespace = nc.oid AND c.relkind = 'v' AND (NOT pg_is_other_temp_schema(nc.oid)) AND (pg_has_role(c.relowner, 'USAGE') OR has_table_privilege(c.oid, 'SELECT') OR has_table_privilege(c.oid, 'INSERT') OR has_table_privilege(c.oid, 'UPDATE') OR has_table_privilege(c.oid, 'DELETE') OR has_table_privilege(c.oid, 'REFERENCES') OR has_table_privilege(c.oid, 'TRIGGER') ); 
SELECT public.gpviewcopy('@gpupgradeschemaname@.gp_migrator_staging_view'::regclass, '@gpinfoschemaname@.views'::regclass);
DROP VIEW @gpupgradeschemaname@.gp_migrator_staging_view;

-- information_schema._pg_keyissubset()
CREATE OR REPLACE FUNCTION @gpinfoschemaname@._pg_keyissubset(smallint[], smallint[]) RETURNS boolean LANGUAGE internal IMMUTABLE AS 'gp_deprecated';

-- information_schema._pg_keysequal()
CREATE OR REPLACE FUNCTION @gpinfoschemaname@._pg_keysequal(smallint[], smallint[]) RETURNS boolean LANGUAGE sql IMMUTABLE AS 'select $1 <@ $2 and $2 <@ $1';

-- information_schema.yes_or_no
CREATE DOMAIN @gpinfoschemaname@.yes_or_no AS character varying(3) CONSTRAINT yes_or_no_check CHECK (value IN ('YES', 'NO'));

-- information_schema.sql_parts
UPDATE @gpinfoschemaname@.sql_parts SET is_supported = 'NO';

-- We just messed with pg_rewrite, so we need to reindex it again.
reindex table @gpupgradeschemaname@.pg_rewrite;

-- Restore original search path
set search_path='public';

DROP FUNCTION public.gpviewcopy(oid, oid);
DROP FUNCTION public.gpviewreparse(text);

-- bootstrap done, re-enable persistent node tables now that they exist.
set gp_before_persistence_work=false;

commit;

-- end
