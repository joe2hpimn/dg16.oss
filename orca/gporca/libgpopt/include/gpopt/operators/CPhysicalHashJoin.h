//---------------------------------------------------------------------------
//	Greenplum Database
//	Copyright (C) 2012 EMC Corp.
//
//	@filename:
//		CPhysicalHashJoin.h
//
//	@doc:
//		Base hash join operator
//
//	@owner:
//		
//
//	@test:
//
//
//---------------------------------------------------------------------------
#ifndef GPOPT_CPhysicalHashJoin_H
#define GPOPT_CPhysicalHashJoin_H

#include "gpos/base.h"
#include "gpopt/operators/CPhysicalJoin.h"
#include "gpos/sync/CMutex.h"

namespace gpopt
{

	// fwd declarations
	class CDistributionSpecHashed;

	//---------------------------------------------------------------------------
	//	@class:
	//		CPhysicalHashJoin
	//
	//	@doc:
	//		Base hash join operator
	//
	//---------------------------------------------------------------------------
	class CPhysicalHashJoin : public CPhysicalJoin
	{

		private:

			//---------------------------------------------------------------------------
			//	@class:
			//		CPartPropReq
			//
			//	@doc:
			//		Partition propagation request generated by hash join
			//
			//---------------------------------------------------------------------------
			class CPartPropReq : public CRefCount
			{

				private:

					// required part propagation
					CPartitionPropagationSpec *m_pppsRequired;

					// child index to push requirements to
					ULONG m_ulChildIndex;

					// id of outer child
					ULONG m_ulOuterChild;

					// id of inner child
					ULONG m_ulInnerChild;

					// id of scalar child
					ULONG m_ulScalarChild;

					// private copy ctor
					CPartPropReq(const CPartPropReq&);

				public:

					// ctor
					CPartPropReq
						(
						CPartitionPropagationSpec *pppsRequired,
						ULONG ulChildIndex,
						ULONG ulOuterChild,
						ULONG ulInnerChild,
						ULONG ulScalarChild
						)
						:
						m_pppsRequired(pppsRequired),
						m_ulChildIndex(ulChildIndex),
						m_ulOuterChild(ulOuterChild),
						m_ulInnerChild(ulInnerChild),
						m_ulScalarChild(ulScalarChild)
					{
						GPOS_ASSERT(NULL != pppsRequired);
					}

					// dtor
					virtual
					~CPartPropReq()
					{
						m_pppsRequired->Release();
					}

					// partition propgataion spec
					CPartitionPropagationSpec *Ppps() const
					{
						return m_pppsRequired;
					}

					// child index to push requirements to
					ULONG UlChildIndex() const
					{
						return m_ulChildIndex;
					}

					// outer child id
					ULONG UlOuterChild() const
					{
						return m_ulOuterChild;
					}

					// inner child id
					ULONG UlInnerChild() const
					{
						return m_ulInnerChild;
					}

					// scalar child id
					ULONG UlScalarChild() const
					{
						return m_ulScalarChild;
					}

					// hash function
					static
					ULONG UlHash(const CPartPropReq *pppr);

					// equality function
					static
					BOOL FEqual(const CPartPropReq *ppprFst, const CPartPropReq *ppprSnd);

			}; // class CPartPropReq

			// map partition propagation request to partition propagation spec
			typedef CHashMap<CPartPropReq, CPartitionPropagationSpec, CPartPropReq::UlHash, CPartPropReq::FEqual,
						CleanupRelease<CPartPropReq>, CleanupRelease<CPartitionPropagationSpec> > HMPartPropagation;

			// the array of expressions from the outer relation
			// that are extracted from the hashing condition
			DrgPexpr *m_pdrgpexprOuterKeys;

			// the array of expressions from the inner relation
			// that are extracted from the hashing condition
			DrgPexpr *m_pdrgpexprInnerKeys;

			// array redistribute request sent to the first hash join child
			DrgPds *m_pdrgpdsRedistributeRequests;

			// partition propagation request map
			HMPartPropagation *m_phmpp;

			// mutex for locking partition propagation request map during lookup/insertion
			CMutex m_mutex;

			// private copy ctor
			CPhysicalHashJoin(const CPhysicalHashJoin &);

			// create the set of redistribute requests to send to first hash join child
			void CreateHashRedistributeRequests(IMemoryPool *pmp);

			// compute a distribution matching the distribution delivered by given child
			CDistributionSpec *PdsMatch(IMemoryPool *pmp, CDistributionSpec *pds, ULONG ulSourceChildIndex) const;

			// compute required hashed distribution from the n-th child
			CDistributionSpecHashed *PdshashedRequired(IMemoryPool *pmp, ULONG ulChildIndex, ULONG ulReqIndex) const;

			// create (redistribute, redistribute) optimization request
			CDistributionSpec *PdsRequiredRedistribute
				(
				IMemoryPool *pmp,
				CExpressionHandle &exprhdl,
				CDistributionSpec *pdsInput,
				ULONG  ulChildIndex,
				DrgPdp *pdrgpdpCtxt,
				ULONG ulOptReq
				)
				const;

			// create (non-singleton, replicate) optimization request
			CDistributionSpec *PdsRequiredReplicate
				(
				IMemoryPool *pmp,
				CExpressionHandle &exprhdl,
				CDistributionSpec *pdsInput,
				ULONG  ulChildIndex,
				DrgPdp *pdrgpdpCtxt,
				ULONG ulOptReq
				)
				const;

			// create (singleton, singleton) optimization request
			CDistributionSpec *PdsRequiredSingleton
				(
				IMemoryPool *pmp,
				CExpressionHandle &exprhdl,
				CDistributionSpec *pdsInput,
				ULONG  ulChildIndex,
				DrgPdp *pdrgpdpCtxt
				)
				const;

			// create a child hashed distribution request based on input hashed distribution,
			// return NULL if no such request can be created
			CDistributionSpecHashed *PdshashedPassThru
				(
				IMemoryPool *pmp,
				CExpressionHandle  &exprhdl,
				CDistributionSpecHashed *pdshashedInput,
				ULONG  ulChildIndex,
				DrgPdp *pdrgpdpCtxt,
				ULONG ulOptReq
				)
				const;

			// check whether a hash key is nullable
			BOOL FNullableHashKey(ULONG ulKey, CColRefSet *pcrsNotNullInner, BOOL fInner) const;

			// create partition propagation request
			CPartPropReq *PpprCreate
				(
				IMemoryPool *pmp,
				CExpressionHandle &exprhdl,
				CPartitionPropagationSpec *pppsRequired,
				ULONG ulChildIndex
				);

			// compute required partition propagation of the n-th child
			CPartitionPropagationSpec *PppsRequiredCompute
				(
				IMemoryPool *pmp,
				CExpressionHandle &exprhdl,
				CPartitionPropagationSpec *pppsRequired,
				ULONG ulChildIndex
				);

		protected:
			
			// helper for computing a hashed distribution matching the given distribution
                        CDistributionSpecHashed *PdshashedMatching(IMemoryPool *pmp, CDistributionSpecHashed *pdshashed, ULONG ulSourceChild) const;

			// check whether the hash keys from one child are nullable
			BOOL FNullableHashKeys(CColRefSet *pcrsNotNullInner, BOOL fInner) const;

			// helper function for computing the required partition propagation 
			// spec for the children of a hash join
			CPartitionPropagationSpec *PppsRequiredHashJoinChild
				(
				IMemoryPool *pmp,
				CExpressionHandle &exprhdl,
				CPartitionPropagationSpec *pppsRequired,
				ULONG ulChildIndex,
				DrgPdp *pdrgpdpCtxt
				);
			
		public:

			// ctor
			CPhysicalHashJoin
				(
				IMemoryPool *pmp,
				DrgPexpr *pdrgpexprOuterKeys,
				DrgPexpr *pdrgpexprInnerKeys
				);

			// dtor
			virtual
			~CPhysicalHashJoin();

			// inner keys
			const DrgPexpr *PdrgpexprInnerKeys() const
			{
				return m_pdrgpexprInnerKeys;
			}

			// outer keys
			const DrgPexpr *PdrgpexprOuterKeys() const
			{
				return m_pdrgpexprOuterKeys;
			}

			//-------------------------------------------------------------------------------------
			// Required Plan Properties
			//-------------------------------------------------------------------------------------

			// compute required sort order of the n-th child
			virtual
			COrderSpec *PosRequired
				(
				IMemoryPool *pmp,
				CExpressionHandle &exprhdl,
				COrderSpec *posInput,
				ULONG ulChildIndex,
				DrgPdp *pdrgpdpCtxt,
				ULONG ulOptReq
				)
				const;

			// compute required rewindability of the n-th child
			virtual
			CRewindabilitySpec *PrsRequired
				(
				IMemoryPool *pmp,
				CExpressionHandle &exprhdl,
				CRewindabilitySpec *prsRequired,
				ULONG ulChildIndex,
				DrgPdp *pdrgpdpCtxt,
				ULONG ulOptReq
				)
				const;

			// compute required distribution of the n-th child
			virtual
			CDistributionSpec *PdsRequired
				(
				IMemoryPool *pmp,
				CExpressionHandle &exprhdl,
				CDistributionSpec *pdsRequired,
				ULONG ulChildIndex,
				DrgPdp *pdrgpdpCtxt,
				ULONG ulOptReq
				)
				const;

			//-------------------------------------------------------------------------------------
			// Derived Plan Properties
			//-------------------------------------------------------------------------------------

			// derive sort order
			virtual
			COrderSpec *PosDerive
				(
				IMemoryPool *pmp,
				CExpressionHandle & // exprhdl
				)
				const
			{
				// hash join is not order-preserving
				return GPOS_NEW(pmp) COrderSpec(pmp);
			}

			//-------------------------------------------------------------------------------------
			// Enforced Properties
			//-------------------------------------------------------------------------------------

			// return order property enforcing type for this operator
			virtual
			CEnfdProp::EPropEnforcingType EpetOrder
				(
				CExpressionHandle &exprhdl,
				const CEnfdOrder *peo
				) const;

			
			//-------------------------------------------------------------------------------------
			//-------------------------------------------------------------------------------------
			//-------------------------------------------------------------------------------------

			// execution order of children
			virtual
			EChildExecOrder Eceo() const
			{
				// TODO - ; 01/06/2014
				// obtain this property by through MD abstraction layer, similar to scalar properties

				// hash join in GPDB executes its inner (right) child first,
				// the optimization order of hash join children follows the execution order
				return EceoRightToLeft;
			}

			// conversion function
			static
			CPhysicalHashJoin *PopConvert
				(
				COperator *pop
				)
			{
				GPOS_ASSERT(CUtils::FHashJoin(pop));

				return dynamic_cast<CPhysicalHashJoin*>(pop);
			}

	}; // class CPhysicalHashJoin

}

#endif // !GPOPT_CPhysicalHashJoin_H

// EOF
