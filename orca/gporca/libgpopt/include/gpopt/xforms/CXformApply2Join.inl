//---------------------------------------------------------------------------
//	Greenplum Database
//	Copyright (C) 2011 EMC Corp.
//
//	@filename:
//		CXformApply2Join.inl
//
//	@doc:
//		Template implementation of transformer
//
//	@owner:
//		
//
//	@test:
//
//
//---------------------------------------------------------------------------
#ifndef GPOPT_CXformApply2Join_INL
#define GPOPT_CXformApply2Join_INL

#include "gpopt/operators/ops.h"
#include "gpopt/operators/CNormalizer.h"
#include "gpopt/operators/CPredicateUtils.h"

#include "gpopt/xforms/CDecorrelator.h"

namespace gpopt
{
	using namespace gpos;

	//---------------------------------------------------------------------------
	//	@class:
	//			CXformApply2Join<TApply, TJoin>::CXformApply2Join
	//
	//	@doc:
	//		ctor for deep tree pattern;
	//		used when Apply's inner child has outer references
	//
	//
	//---------------------------------------------------------------------------
	template<class TApply, class TJoin>
	CXformApply2Join<TApply, TJoin>::CXformApply2Join
		(
		IMemoryPool *pmp,
		BOOL // fDeepTree
		)
		:
		// pattern
		CXformExploration
			(
			GPOS_NEW(pmp) CExpression
				(
				pmp, 
				GPOS_NEW(pmp) TApply(pmp),
				GPOS_NEW(pmp) CExpression(pmp, GPOS_NEW(pmp) CPatternLeaf(pmp)), // left child
				GPOS_NEW(pmp) CExpression(pmp, GPOS_NEW(pmp) CPatternTree(pmp)), // right child
				GPOS_NEW(pmp) CExpression(pmp, GPOS_NEW(pmp) CPatternTree(pmp)) // predicate
				)
			)
	{}
	
	//---------------------------------------------------------------------------
	//	@class:
	//			CXformApply2Join<TApply, TJoin>::CXformApply2Join
	//
	//	@doc:
	//		ctor for leaf pattern;
	//		used when Apply's inner child has no outer references 
	//
	//
	//---------------------------------------------------------------------------
	template<class TApply, class TJoin>
	CXformApply2Join<TApply, TJoin>::CXformApply2Join
		(
		IMemoryPool *pmp
		)
		:
		// pattern
		CXformExploration
			(
			GPOS_NEW(pmp) CExpression
				(
				pmp, 
				GPOS_NEW(pmp) TApply(pmp),
				GPOS_NEW(pmp) CExpression(pmp, GPOS_NEW(pmp) CPatternLeaf(pmp)), // left child
				GPOS_NEW(pmp) CExpression(pmp, GPOS_NEW(pmp) CPatternLeaf(pmp)), // right child
				GPOS_NEW(pmp) CExpression(pmp, GPOS_NEW(pmp) CPatternLeaf(pmp)) // predicate
				)
			)
	{}
	
	
	//---------------------------------------------------------------------------
	//	@class:
	//		CXformApply2Join<TApply, TJoin>::FDecorrelate
	//
	//	@doc:
	//		Helper function to decorrelate inner child of Apply expression
	//
	//---------------------------------------------------------------------------
	template<class TApply, class TJoin>
	BOOL CXformApply2Join<TApply, TJoin>::FDecorrelate
		(
		IMemoryPool *pmp,
		CExpression *pexprApply,
		CExpression **ppexprInner,
		DrgPexpr **ppdrgpexpr
		) 
	{
		GPOS_ASSERT(NULL != pexprApply);
		GPOS_ASSERT(NULL != ppexprInner);
		GPOS_ASSERT(NULL != ppdrgpexpr);
		
		*ppdrgpexpr = GPOS_NEW(pmp) DrgPexpr(pmp);
		
		CExpression *pexprPredicateOrig = (*pexprApply)[2];
			
		// add original predicate to array
		pexprPredicateOrig->AddRef();
		(*ppdrgpexpr)->Append(pexprPredicateOrig);
			
		// since properties of inner child have been copied from 
		// groups that may had subqueries that were decorrelated later, we reset
		// properties here to allow re-computing them during decorrelation
		(*pexprApply)[1]->ResetDerivedProperties();
			
		// decorrelate inner child
		if (!CDecorrelator::FProcess(pmp, (*pexprApply)[1], false /*fEqualityOnly*/, ppexprInner, *ppdrgpexpr))
		{
			// decorrelation filed
			(*ppdrgpexpr)->Release();
			return false;
		}
		
		// check for valid semi join correlations
		if (
			(COperator::EopLogicalLeftSemiJoin == pexprApply->Pop()->Eopid() ||
			COperator::EopLogicalLeftAntiSemiJoin == pexprApply->Pop()->Eopid()) &&
			!CPredicateUtils::FValidSemiJoinCorrelations(pmp, (*pexprApply)[0], (*ppexprInner), (*ppdrgpexpr))
			)
		{
			(*ppdrgpexpr)->Release();

			return false;
	 	}
		
		return true;
	}
	
	
	//---------------------------------------------------------------------------
	//	@class:
	//		CXformApply2Join<TApply, TJoin>::FCanCreateCorrelatedApply
	//
	//	@doc:
	//		Check if we can create a correlated apply expression from the given expression
	//
	//---------------------------------------------------------------------------
	template<class TApply, class TJoin>
	BOOL CXformApply2Join<TApply, TJoin>::FCanCreateCorrelatedApply
		(
		IMemoryPool *, // pmp
		CExpression *pexprApply
		) 
	{
		GPOS_ASSERT(NULL != pexprApply);
		
		COperator::EOperatorId eopid = pexprApply->Pop()->Eopid();
		
		// consider only Inner/Outer/Left (Anti) Semi Apply here,
		// correlated left anti semi apply (with ALL/NOT-IN semantics) can only be generated by SubqueryHandler
		return 
			COperator::EopLogicalInnerApply == eopid ||
			COperator::EopLogicalLeftOuterApply == eopid ||
			COperator::EopLogicalLeftSemiApply == eopid ||
			COperator::EopLogicalLeftSemiApplyIn == eopid ||
			COperator::EopLogicalLeftAntiSemiApply == eopid;
	}
	
	//---------------------------------------------------------------------------
	//	@class:
	//		CXformApply2Join<TApply, TJoin>::CreateCorrelatedApply
	//
	//	@doc:
	//		Create correlated apply expression
	//
	//---------------------------------------------------------------------------
	template<class TApply, class TJoin>
	void CXformApply2Join<TApply, TJoin>::CreateCorrelatedApply
		(
		IMemoryPool *pmp,
		CExpression *pexprApply,
		CXformResult *pxfres
		) 
	{
		if (!FCanCreateCorrelatedApply(pmp, pexprApply))
		{
			return;
		}
		
		CExpression *pexprInner = (*pexprApply)[1];
		CExpression *pexprOuter = (*pexprApply)[0];
		CExpression *pexprScalar = (*pexprApply)[2];

		pexprOuter->AddRef();
		pexprInner->AddRef();
		pexprScalar->AddRef();
		CExpression *pexprResult = NULL;
		
		TApply *popApply = TApply::PopConvert(pexprApply->Pop());
		DrgPcr *pdrgpcr = popApply->PdrgPcrInner();
		GPOS_ASSERT(NULL != pdrgpcr);
		GPOS_ASSERT(1 == pdrgpcr->UlLength());
			
		pdrgpcr->AddRef();
		COperator::EOperatorId eopidSubq = popApply->EopidOriginSubq();
		COperator::EOperatorId eopid = pexprApply->Pop()->Eopid();
		switch (eopid)
		{
		 	case COperator::EopLogicalInnerApply:
				pexprResult = CUtils::PexprLogicalApply<CLogicalInnerCorrelatedApply>(pmp, pexprOuter, pexprInner, pdrgpcr, eopidSubq, pexprScalar);
				break;
					
			case COperator::EopLogicalLeftOuterApply:
				pexprResult = CUtils::PexprLogicalApply<CLogicalLeftOuterCorrelatedApply>(pmp, pexprOuter, pexprInner, pdrgpcr, eopidSubq, pexprScalar);
				break;

			case COperator::EopLogicalLeftSemiApply:
				pexprResult = CUtils::PexprLogicalApply<CLogicalLeftSemiCorrelatedApply>(pmp, pexprOuter, pexprInner, pdrgpcr, eopidSubq, pexprScalar);
				break;
					
			case COperator::EopLogicalLeftSemiApplyIn:
				pexprResult = CUtils::PexprLogicalCorrelatedQuantifiedApply<CLogicalLeftSemiCorrelatedApplyIn>(pmp, pexprOuter, pexprInner, pdrgpcr, eopidSubq, pexprScalar);
				break;
				
			case COperator::EopLogicalLeftAntiSemiApply:
				pexprResult = CUtils::PexprLogicalApply<CLogicalLeftAntiSemiCorrelatedApply>(pmp, pexprOuter, pexprInner, pdrgpcr, eopidSubq, pexprScalar);
				break;
	
			default:
				GPOS_ASSERT(!"Unexpected Apply operator");
				return;
		}
		
		pxfres->Add(pexprResult);
	}
	
	//---------------------------------------------------------------------------
	//	@class:
	//		CXformApply2Join<TApply, TJoin>::Decorrelate
	//
	//	@doc:
	//		Transform Apply into Join by decorrelating the inner side
	//
	//---------------------------------------------------------------------------
	template<class TApply, class TJoin>
	void CXformApply2Join<TApply, TJoin>::Decorrelate
		(
		CXformContext *pxfctxt,
		CXformResult *pxfres,
		CExpression *pexprApply
		) 
	{
		GPOS_ASSERT(CUtils::FHasOuterRefs((*pexprApply)[1])
					&& "Apply's inner child must have outer references");
		
		if (CUtils::FHasSubqueryOrApply((*pexprApply)[1]))
		{
			// Subquery/Apply must be unnested before reaching here
			return;
		}
		
		IMemoryPool *pmp = pxfctxt->Pmp();
		DrgPexpr *pdrgpexpr = NULL;
		CExpression *pexprInner = NULL;
		if (!FDecorrelate(pmp, pexprApply, &pexprInner, &pdrgpexpr))
		{
			// decorrelation failed, create correlated apply expression if possible
			CreateCorrelatedApply(pmp, pexprApply, pxfres);
					
			return;
		}
		
		// build substitute
		GPOS_ASSERT(NULL != pexprInner);
		(*pexprApply)[0]->AddRef();
		CExpression *pexprOuter = (*pexprApply)[0];
		CExpression *pexprPredicate = CPredicateUtils::PexprConjunction(pmp, pdrgpexpr);
			
		CExpression *pexprResult =
				GPOS_NEW(pmp) CExpression
						(
						pmp, 
						GPOS_NEW(pmp) TJoin(pmp), // join operator
						pexprOuter, 
						pexprInner, 
						pexprPredicate
						);

		// add alternative to results
		pxfres->Add(pexprResult);
	}
	
	
	//---------------------------------------------------------------------------
	//	@class:
	//		CXformApply2Join<TApply, TJoin>::CreateJoinAlternative
	//
	//	@doc:
	//		Transform Apply into Join when Apply's inner child has no outer 
	//		references
	//
	//---------------------------------------------------------------------------
	template<class TApply, class TJoin>
	void CXformApply2Join<TApply, TJoin>::CreateJoinAlternative
		(
		CXformContext *pxfctxt,
		CXformResult *pxfres,
		CExpression *pexprApply
		) 
	{
#ifdef GPOS_DEBUG
		CExpressionHandle exprhdl(pxfctxt->Pmp());
		exprhdl.Attach(pexprApply);
		GPOS_ASSERT_IMP(CUtils::FHasOuterRefs((*pexprApply)[1]), !exprhdl.Pdprel(1)->PcrsOuter()->FSubset(exprhdl.Pdprel(0)->PcrsOutput())
					&& "Apply's inner child can only use external columns");
#endif // GPOS_DEBUG
		
		IMemoryPool *pmp = pxfctxt->Pmp();
		CExpression *pexprOuter = (*pexprApply)[0];
		CExpression *pexprInner = (*pexprApply)[1];	
		CExpression *pexprPred = (*pexprApply)[2];
		pexprOuter->AddRef();
		pexprInner->AddRef();
		pexprPred->AddRef();
		CExpression *pexprResult = 
				GPOS_NEW(pmp) CExpression
					(
					pmp, 
					GPOS_NEW(pmp) TJoin(pmp), // join operator
					pexprOuter, 
					pexprInner, 
					pexprPred
					);

		// add alternative to results
		pxfres->Add(pexprResult);
	}
}

#endif // !GPOPT_CXformApply2Join_INL

// EOF
