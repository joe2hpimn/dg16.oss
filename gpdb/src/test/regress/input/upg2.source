-- -*- mode: sql; -*-
--
-- upgrade 2
--

--
-- Load in data which represents the difference between the 3.2 catalog,
-- 3.3 catalog, and 3.4 catalogs
--

-- start_matchsubs
-- m|base/\d+|
-- s|base/\d+|base/OID|
--
-- m/ERROR:.*Persistent database entry.*already exists in state/
-- s/\.c\:\d+\)/\.c\:SOME_LINE\)/
--
-- end_matchsubs

--
-- save the catalog info for previous revision
-- COPY pg_attribute
--   to '@abs_srcdir@/data/pg_attribute32.data'  csv header;
-- COPY pg_class
--   to '@abs_srcdir@/data/pg_class32.data' with oids csv header;
-- COPY pg_type
--   to '@abs_srcdir@/data/pg_type32.data' with oids csv header;
--

-- The structure of this test is:
--    1. Build the 32 catalog
--    2. Bulid the 33 catalog
--    3. Load the 32 catalog into public
--    4. Load the 33 catalog into public (with different names)
--    5. Run the scripts that upgrade from 32->33
--    6. Compare upgraded 32 to loaded 33
--    7. Run the scripts that upgrade from 33->34
--    8. Compare upgraded 33 to actual 34
--    9. Final sanity checks and cleanup
--

--
-- 1. Build the 32 catalog
--
create table public.pg_attribute (like pg_catalog.pg_attribute);
create table public.pg_class (like pg_catalog.pg_class) with oids;
create table public.pg_type (like pg_catalog.pg_type) with oids;
create table public.pg_index (like pg_catalog.pg_index);
create table public.pg_proc (like pg_catalog.pg_proc) with oids;
create table public.pg_namespace (like pg_catalog.pg_namespace) with oids;
create table public.pg_depend (like pg_catalog.pg_depend);
create table public.pg_description(like pg_catalog.pg_description);
create table public.pg_shdepend (like pg_catalog.pg_shdepend);
create table public.pg_shdescription (like pg_catalog.pg_shdescription);
create table public.pg_rewrite (like pg_catalog.pg_rewrite) with oids;
create table public.pg_conversion (like pg_catalog.pg_conversion);
create table public.pg_operator (like pg_catalog.pg_operator) with oids;
create table public.pg_resqueue (like pg_catalog.pg_resqueue) with oids;
create table public.pg_amop (like pg_catalog.pg_amop);
create table public.pg_amproc (like pg_catalog.pg_amproc);
create table public.pg_cast (like pg_catalog.pg_cast) with oids;
create table public.pg_opclass(like pg_catalog.pg_opclass) with oids;

-- don't use LIKE, as 3.2 has a different structure
create table public.pg_aggregate (aggfnoid        regproc  not null,
                                  aggtransfn      regproc  not null,
                                  agginvtransfn   regproc  not null,
                                  aggprelimfn     regproc  not null,
                                  agginvprelimfn  regproc  not null,
                                  aggfinalfn      regproc  not null,
                                  aggsortop       oid      not null,
                                  aggtranstype    oid      not null,
                                  agginitval      text) with oids;
create table public.pg_appendonly (relid oid,
                                   blocksize integer,
                                   safefswritesize integer,
                                   compresslevel smallint,
                                   majorversion smallint,
                                   minorversion smallint,
                                   checksum boolean);
create table public.pg_exttable (reloid oid not null,
	   		 					 location text[],
								 fmttype char,
								 fmtopts text,
								 command text,
								 rejectlimit integer,
								 rejectlimittype char,
								 fmterrtbl oid,
								 encoding integer);
create table public.pg_tablespace(spcname name not null,
	   		 					  spcowner oid not null,
								  spclocation text,
								  spcacl aclitem[],
								  spcprilocations text[],
								  spcmirlocations text[]
 								  ) with oids;
create table public.pg_authid ( rolname name NOT NULL,
    							rolsuper boolean NOT NULL,
								rolinherit boolean NOT NULL,
								rolcreaterole boolean NOT NULL,
								rolcreatedb boolean NOT NULL,
								rolcatupdate boolean NOT NULL,
								rolcanlogin boolean NOT NULL,
								rolconnlimit integer NOT NULL,
								rolpassword text,
								rolvaliduntil timestamp with time zone,
								rolconfig text[],
								rolresqueue oid);
create table public.pg_partition_rule ( paroid oid NOT NULL,
										parchildrelid oid NOT NULL,
										parparentrule oid NOT NULL,
										parname name NOT NULL,
										parisdefault boolean NOT NULL,
										parruleord smallint NOT NULL,
										parrangestartincl boolean NOT NULL,
										parrangeendincl boolean NOT NULL,
										parrangestart text,
										parrangeend text,
										parrangeevery text,
										parlistvalues text,
										parreloptions text[]);

-- These tables we only create so that the REINDEX statements wont error
create table public.gp_configuration(like pg_catalog.gp_configuration);
create table public.gp_configuration_history(like pg_catalog.gp_configuration_history);
create table public.gp_db_interfaces(like pg_catalog.gp_db_interfaces);
create table public.gp_interfaces(like pg_catalog.gp_interfaces);
create table public.gp_san_configuration(like pg_catalog.gp_san_configuration);
create table public.gp_segment_configuration(like pg_catalog.gp_segment_configuration);
create table public.gp_fault_strategy(like pg_catalog.gp_fault_strategy);
create table public.pg_appendonly_alter_column(like pg_catalog.pg_appendonly_alter_column);
create table public.pg_filespace(like pg_catalog.pg_filespace) with oids;
create table public.pg_filespace_entry(like pg_catalog.pg_filespace_entry);
create table public.pg_foreign_data_wrapper(like pg_catalog.pg_foreign_data_wrapper);
create table public.pg_foreign_server(like pg_catalog.pg_foreign_server);
create table public.pg_resourcetype(like pg_catalog.pg_resourcetype) with oids;
create table public.pg_resqueuecapability(like pg_catalog.pg_resqueuecapability);
create table public.pg_stat_last_operation(like pg_catalog.pg_stat_last_operation);
create table public.pg_stat_last_shoperation(like pg_catalog.pg_stat_last_shoperation);
create table public.pg_user_mapping(like pg_catalog.pg_user_mapping);
create table public.gp_fastsequence(like pg_catalog.gp_fastsequence);
create table public.gp_global_sequence(like pg_catalog.gp_global_sequence);
create table public.gp_relation_node(like pg_catalog.gp_relation_node);
create table public.gp_distribution_policy(like pg_catalog.gp_distribution_policy);
create table public.sql_parts(like information_schema.sql_parts);

-- indexes
create unique index gp_configuration_content_definedprimary_index on public.gp_configuration(content, definedprimary);
create        index gp_db_interfaces_dbid_index on public.gp_db_interfaces(dbid);
create unique index gp_interfaces_interface_index on public.gp_interfaces(interfaceid);
create unique index pg_amproc_opc_proc_index on public.pg_amproc (amopclaid, amprocsubtype, amprocnum);
create unique index pg_appendonly_alter_column_relid_index on public.pg_appendonly_alter_column(relid, changenum);
create unique index pg_attribute_relid_attnum_index on public.pg_attribute(attrelid, attnum);
create        index pg_depend_depender_index on public.pg_depend(classid, objid, objsubid);
create unique index pg_filespace_fsname_index on public.pg_filespace(fsname);
create unique index pg_filespace_entry_fsdb_index on public.pg_filespace_entry(fsefsoid,fsedbid);
create unique index pg_operator_oid_index on public.pg_operator(oid);
create unique index pg_resourcetype_oid_index on public.pg_resourcetype(oid);
create unique index pg_resqueue_oid_index on public.pg_resqueue(oid);
create unique index gp_fastsequence_objid_objmod_index on public.gp_fastsequence(objid, objmod);
create unique index gp_relation_node_index on public.gp_relation_node(relfilenode_oid,segment_file_num);

--
-- 2. Build the 33 catalog
--
create table public.pg_attribute_v33 (like pg_catalog.pg_attribute);
create table public.pg_class_v33 (like pg_catalog.pg_class) with oids;
create table public.pg_type_v33 (like pg_catalog.pg_type) with oids;
create table public.pg_index_v33 (like pg_catalog.pg_index);
create table public.pg_proc_v33 (like pg_catalog.pg_proc) with oids;
create table public.pg_namespace_v33 (like pg_catalog.pg_namespace) with oids;
create table public.pg_aggregate_v33 (like pg_catalog.pg_aggregate) with oids;
create table public.pg_depend_v33 (like pg_catalog.pg_depend);
create table public.pg_description_v33(like pg_catalog.pg_description);
create table public.pg_shdepend_v33 (like pg_catalog.pg_shdepend);
create table public.pg_shdescription_v33(like pg_catalog.pg_shdescription);
create table public.pg_rewrite_v33(like pg_catalog.pg_rewrite) with oids;
create table public.pg_conversion_v33(like pg_catalog.pg_conversion);
create table public.pg_operator_v33 (like pg_catalog.pg_operator) with oids;
create table public.pg_resqueue_v33 (like pg_catalog.pg_resqueue) with oids;
create table public.pg_amop_v33 (like pg_catalog.pg_amop);
create table public.pg_amproc_v33 (like pg_catalog.pg_amproc);
create table public.pg_cast_v33 (like pg_catalog.pg_cast) with oids;
create table public.pg_opclass_v33(like pg_catalog.pg_opclass) with oids;

-- don't use LIKE, as 3.3 had a different structure
create table public.pg_appendonly_v33 (relid oid,
                                   blocksize integer,
                                   safefswritesize integer,
                                   compresslevel smallint,
                                   majorversion smallint,
                                   minorversion smallint,
                                   checksum boolean,
								   compresstype text);
create table public.pg_exttable_v33 (reloid oid not null,
	   		 					 	 location text[],
								 	 fmttype char,
								 	 fmtopts text,
								 	 command text,
								 	 rejectlimit integer,
								 	 rejectlimittype char,
								 	 fmterrtbl oid,
								 	 encoding integer);
create table public.pg_authid_v33 ( rolname name NOT NULL,
    								rolsuper boolean NOT NULL,
								    rolinherit boolean NOT NULL,
								    rolcreaterole boolean NOT NULL,
								    rolcreatedb boolean NOT NULL,
								    rolcatupdate boolean NOT NULL,
								    rolcanlogin boolean NOT NULL,
								    rolconnlimit integer NOT NULL,
								    rolpassword text,
								    rolvaliduntil timestamp with time zone,
								    rolconfig text[],
								    rolresqueue oid);
create table public.pg_partition_rule_v33 ( paroid oid NOT NULL,
											parchildrelid oid NOT NULL,
											parparentrule oid NOT NULL,
											parname name NOT NULL,
											parisdefault boolean NOT NULL,
											parruleord smallint NOT NULL,
											parrangestartincl boolean NOT NULL,
											parrangeendincl boolean NOT NULL,
											parrangestart text,
											parrangeend text,
											parrangeevery text,
											parlistvalues text,
											parreloptions text[]);

--
-- 3. Load the 32 catalog into public
--
COPY public.pg_attribute
  from '@abs_srcdir@/data/pg_attribute32.data'  csv header;
COPY public.pg_class
  from '@abs_srcdir@/data/pg_class32.data' with oids csv header;
COPY public.pg_type
  from '@abs_srcdir@/data/pg_type32.data' with oids csv header;
COPY public.pg_index
  from '@abs_srcdir@/data/pg_index32.data' csv header;
COPY public.pg_proc
  from '@abs_srcdir@/data/pg_proc32.data' with oids csv header;
COPY public.pg_aggregate
  from '@abs_srcdir@/data/pg_aggregate32.data' csv header;
COPY public.pg_namespace
  from '@abs_srcdir@/data/pg_namespace32.data' with oids csv header;
COPY public.pg_description
  from '@abs_srcdir@/data/pg_description32.data' csv header;
COPY public.pg_depend
  from '@abs_srcdir@/data/pg_depend32.data' csv header;
COPY public.pg_shdepend
  from '@abs_srcdir@/data/pg_shdepend32.data' csv header;
COPY public.pg_shdescription
  from '@abs_srcdir@/data/pg_shdescription32.data' csv header;
COPY public.pg_rewrite
  from '@abs_srcdir@/data/pg_rewrite32.data' oids csv header;
COPY public.pg_conversion
  from '@abs_srcdir@/data/pg_conversion32.data' csv header;
COPY public.pg_operator
  from '@abs_srcdir@/data/pg_operator32.data' with oids csv header;
COPY public.pg_amop
  from '@abs_srcdir@/data/pg_amop32.data'  csv header;
COPY public.pg_amproc
  from '@abs_srcdir@/data/pg_amproc32.data'  csv header;
COPY public.pg_cast
  from '@abs_srcdir@/data/pg_cast32.data' with oids csv header;
COPY public.pg_opclass
  from '@abs_srcdir@/data/pg_opclass32.data' with oids csv header;
COPY public.pg_tablespace
  from '@abs_srcdir@/data/pg_tablespace32.data' with oids csv header;

\i @abs_srcdir@/sql/upg2_viewdefs_32.sql

--
-- 4. Load the 33 catalog into public (with different names)
--
COPY public.pg_attribute_v33
  from '@abs_srcdir@/data/pg_attribute33.data'  csv header;
COPY public.pg_class_v33
  from '@abs_srcdir@/data/pg_class33.data' with oids csv header;
COPY public.pg_type_v33
  from '@abs_srcdir@/data/pg_type33.data' with oids csv header;
COPY public.pg_index_v33
  from '@abs_srcdir@/data/pg_index33.data' csv header;
COPY public.pg_proc_v33
  from '@abs_srcdir@/data/pg_proc33.data' with oids csv header;
COPY public.pg_aggregate_v33
  from '@abs_srcdir@/data/pg_aggregate33.data' csv header;
COPY public.pg_namespace_v33
  from '@abs_srcdir@/data/pg_namespace33.data' with oids csv header;
COPY public.pg_description_v33
  from '@abs_srcdir@/data/pg_description33.data' csv header;
COPY public.pg_depend_v33
  from '@abs_srcdir@/data/pg_depend33.data' csv header;
COPY public.pg_shdepend_v33
  from '@abs_srcdir@/data/pg_shdepend33.data' csv header;
COPY public.pg_shdescription_v33
  from '@abs_srcdir@/data/pg_shdescription33.data' csv header;
COPY public.pg_rewrite_v33
  from '@abs_srcdir@/data/pg_rewrite33.data' oids csv header;
COPY public.pg_conversion_v33
  from '@abs_srcdir@/data/pg_conversion33.data' csv header;
COPY public.pg_operator_v33
  from '@abs_srcdir@/data/pg_operator33.data' with oids csv header;
COPY public.pg_amop_v33
  from '@abs_srcdir@/data/pg_amop33.data'  csv header;
COPY public.pg_amproc_v33
  from '@abs_srcdir@/data/pg_amproc33.data'  csv header;
COPY public.pg_cast_v33
  from '@abs_srcdir@/data/pg_cast33.data' with oids csv header;
COPY public.pg_opclass_v33
  from '@abs_srcdir@/data/pg_opclass33.data' with oids csv header;

-- create a 3.3 version of gp_configuration based on gp_segment_configuration
insert into public.gp_configuration (
  SELECT content, preferred_role='p' as definedprimary, dbid, role='p' as isprimary,
         status='u' as valid, address as hostname, port, fselocation as datadir 
  FROM pg_catalog.gp_segment_configuration join pg_filespace_entry ON (dbid = fsedbid)
  WHERE fsefsoid = 3052 -- pg_system filespace
);

-- the 3.3 pg_partitions
create view public.pg_partitions_v33 as
select 
schemaname,
tablename, 
partitionschemaname,
partitiontablename,
partitionname,
parentpartitiontablename,
parentpartitionname,
partitiontype, 
partitionlevel,
-- if not a range partition, no partition rank
-- for range partitions, the parruleord of the default partition is zero,
-- so if no_default (min of parruleord) > 0 then there is no default partition
-- so return the normal rank.  However, if there is a default partition, it
-- is rank 1, so skip it, and decrement remaining ranks by 1 so the first
-- non-default partition starts at 1
--
case when (partitiontype != 'range') then NULL
	 when (partitionnodefault > 0) then partitionrank
	 when (partitionrank = 1) then NULL
	 else  partitionrank - 1
end as partitionrank,
partitionposition,
partitionlistvalues,
partitionrangestart,
case when (partitiontype = 'range') then partitionstartinclusive
	 else NULL
end as partitionstartinclusive,
partitionrangeend,
case when (partitiontype = 'range') then partitionendinclusive
	else NULL
end as partitionendinclusive,
partitioneveryclause,
parisdefault as partitionisdefault,
partitionboundary
from
(
select
n.nspname as schemaname,
cl.relname as tablename, 
n2.nspname as partitionschemaname,
cl2.relname as partitiontablename,
pr1.parname as partitionname,
cl3.relname as parentpartitiontablename,
pr2.parname as parentpartitionname,
case when pp.parkind = 'h' then 'hash' when pp.parkind = 'r' then 'range'
	 when pp.parkind = 'l' then 'list' else null end as partitiontype, 
pp.parlevel as partitionlevel,
pr1.parruleord
as partitionposition,
rank() over (partition by pp.oid, cl.relname, pp.parlevel, cl3.relname 
	order by pr1.parruleord) as partitionrank,
pg_get_expr(pr1.parlistvalues, pr1.parchildrelid) as partitionlistvalues,
pg_get_expr(pr1.parrangestart, pr1.parchildrelid) as partitionrangestart,
pr1.parrangestartincl as partitionstartinclusive,
pg_get_expr(pr1.parrangeend, pr1.parchildrelid) as partitionrangeend,
pr1.parrangeendincl as partitionendinclusive,
pg_get_expr(pr1.parrangeevery, pr1.parchildrelid) as partitioneveryclause,
min(pr1.parruleord) 
    over (partition by pp.oid, cl.relname, pp.parlevel, cl3.relname 
	order by pr1.parruleord) as partitionnodefault,
pr1.parisdefault,
pg_get_partition_rule_def(pr1.oid, true) as partitionboundary
from 
pg_namespace n,
pg_namespace n2,
pg_class cl,
pg_class cl2, 
pg_partition pp,
pg_partition_rule pr1 left outer join pg_partition_rule pr2 
   on(pr1.parparentrule = pr2.oid)
left outer join pg_class cl3 on (pr2.parchildrelid = cl3.oid)
where 
 pp.paristemplate = 'f' and -- paristemplate = 't' handled in its on view
 pp.parrelid = cl.oid and 
 pr1.paroid = pp.oid and
 cl2.oid = pr1.parchildrelid and
 cl.relnamespace = n.oid and
 cl2.relnamespace = n2.oid
) as p1;

-- pg_catalog.pg_roles (had not changed from 3.2. changes in 4.0
create view public.pg_roles_v33 as 
    select 
        rolname,
        rolsuper,
        rolinherit,
        rolcreaterole,
        rolcreatedb,
        rolcatupdate,
        rolcanlogin,
        rolconnlimit,
        '********'::text as rolpassword,
        rolvaliduntil,
        rolconfig,
		rolresqueue,
        oid 
    from pg_authid;

--
-- 5. Run the scripts that upgrade from 32->33
--      phase 1:  loadcat33
--      phase 2:  upg2_conversion32.sql
--
\i @abs_srcdir@/sql/loadcat33.sql
\i @abs_srcdir@/data/upg2_conversion32.sql

--
-- Some manual fixups.
--   The above loadcat added some columns to our "public" versions of the
--   catalogs, but this updated the "pg_catalog.pg_attribute".
--   Insert the appropriate rows into the "public.pg_attribute".
--
-- WARNING: DO NOT ADD ACTUAL CATALOG UPGRADE LOGIC HERE!
--
-- This is only to fix the dummy catalog for Alter operations.  When these
-- are run by the loadcat script the tables are only updated in the Real
-- catalog and we must manually update the dummy catalog to account for them.
--
insert into public.pg_attribute 
  select 'pg_catalog.pg_appendonly'::regclass, a.attname, a.atttypid,
    a.attstattarget, a.attlen, a.attnum, a.attndims, a.attcacheoff,
    a.atttypmod, a.attbyval, a.attstorage, a.attalign, a.attnotnull,
    a.atthasdef, a.attisdropped, a.attislocal, a.attinhcount
  from pg_catalog.pg_attribute a
  where (attrelid, attnum) in ( ('public.pg_appendonly'::regclass, 8) );
update public.pg_class set relnatts=8 where oid = 'pg_catalog.pg_appendonly'::regclass;

--
-- 6. Compare upgraded 32 to loaded 33
--

-- new pg_partitions 
--   note that the view changed, public.pg_partitions_v33 should now
--   be the same as public.pg_partitions
--
select pg_get_viewdef(a.ev_class) = pg_get_viewdef(b.ev_class)
from pg_rewrite a, pg_rewrite b
where
a.ev_class = 'public.pg_partitions'::regclass and
b.ev_class = 'public.pg_partitions_v33'::regclass;

-- pg_roles
--   the view did not change, just a sanity check for now.
--
select pg_get_viewdef(a.ev_class) = pg_get_viewdef(b.ev_class)
from pg_rewrite a, pg_rewrite b
where
a.ev_class = 'public.pg_roles'::regclass and
b.ev_class = 'public.pg_roles_v33'::regclass;

-- pg_attribute 
select c.relname, a.attname, a.attnum, t.typname, 
	   a.attlen, a.attndims, a.attcacheoff, a.atttypmod, a.attbyval, 
	   a.attstorage, a.attalign, a.attnotnull, a.atthasdef, a.attisdropped,
	   a.attislocal, a.attinhcount
from public.pg_attribute a
     left join public.pg_class c on (c.oid = a.attrelid)
     left join public.pg_type t on (t.oid = a.atttypid)
     where a.attrelid < 10000
except all
select c.relname, a.attname, a.attnum, t.typname, 
	   a.attlen, a.attndims, a.attcacheoff, a.atttypmod, a.attbyval, 
	   a.attstorage, a.attalign, a.attnotnull, a.atthasdef, a.attisdropped,
	   a.attislocal, a.attinhcount
from public.pg_attribute_v33 a
     left join public.pg_class_v33 c on (c.oid = a.attrelid)
     left join public.pg_type_v33 t on (t.oid = a.atttypid)
     where a.attrelid < 10000;

select c.relname, a.attname, a.attnum, t.typname, 
	   a.attlen, a.attndims, a.attcacheoff, a.atttypmod, a.attbyval, 
	   a.attstorage, a.attalign, a.attnotnull, a.atthasdef, a.attisdropped,
	   a.attislocal, a.attinhcount
from public.pg_attribute_v33 a
     left join public.pg_class_v33 c on (c.oid = a.attrelid)
     left join public.pg_type_v33 t on (t.oid = a.atttypid)
     where a.attrelid < 10000
except all
select c.relname, a.attname, a.attnum, t.typname, 
	   a.attlen, a.attndims, a.attcacheoff, a.atttypmod, a.attbyval, 
	   a.attstorage, a.attalign, a.attnotnull, a.atthasdef, a.attisdropped,
	   a.attislocal, a.attinhcount
from public.pg_attribute a
     left join public.pg_class c on (c.oid = a.attrelid)
     left join public.pg_type t on (t.oid = a.atttypid)
     where a.attrelid < 10000;

-- compare old and new pg_index
select * from public.pg_index_v33 where indexrelid < 10000
except all
select * from public.pg_index where indexrelid < 10000;

select * from public.pg_index where indexrelid < 10000
except all
select * from public.pg_index_v33 where indexrelid < 10000;

-- compare old and new pg_proc (all columns except acl which has sort issues)
select proname, pronamespace, proowner, prolang, proisagg, prosecdef,
       proisstrict, proretset, provolatile, pronargs, prorettype,
       proiswin, proargtypes, proallargtypes, proargmodes, proargnames,
       prosrc, probin
from public.pg_proc_v33 where oid < 10000
except all
select proname, pronamespace, proowner, prolang, proisagg, prosecdef,
       proisstrict, proretset, provolatile, pronargs, prorettype,
       proiswin, proargtypes, proallargtypes, proargmodes, proargnames,
       prosrc, probin
from public.pg_proc where oid < 10000;

select proname, pronamespace, proowner, prolang, proisagg, prosecdef,
       proisstrict, proretset, provolatile, pronargs, prorettype,
       proiswin, proargtypes, proallargtypes, proargmodes, proargnames,
       prosrc, probin
from public.pg_proc where oid < 10000
except all
select proname, pronamespace, proowner, prolang, proisagg, prosecdef,
       proisstrict, proretset, provolatile, pronargs, prorettype,
       proiswin, proargtypes, proallargtypes, proargmodes, proargnames,
       prosrc, probin
from public.pg_proc_v33 where oid < 10000;

-- compare old and new pg_operator
select * from public.pg_operator_v33 where oid < 10000
except all
select * from public.pg_operator where oid < 10000;

select * from public.pg_operator where oid < 10000
except all
select * from public.pg_operator_v33 where oid < 10000;

-- compare old and new pg_class
select relname, relnamespace, 
	   case when reltype > 10000 then 10000 else reltype end as reltype,
       relowner, relam, reltablespace, reltoastrelid, reltoastidxid, 
	   relaosegrelid, relaosegidxid, relhasindex, relisshared, relkind, 
	   relstorage, relnatts, relchecks, reltriggers, relukeys, relfkeys, 
	   relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, reloptions
from public.pg_class_v33 where oid < 10000 and relname !~ 'pg_toast'
except all
select relname, relnamespace, 
	   case when reltype > 10000 then 10000 else reltype end as reltype,
       relowner, relam, reltablespace, reltoastrelid, reltoastidxid, 
	   relaosegrelid, relaosegidxid, relhasindex, relisshared, relkind, 
	   relstorage, relnatts, relchecks, reltriggers, relukeys, relfkeys, 
	   relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, reloptions
from public.pg_class where oid < 10000 and relname !~ 'pg_toast';

select relname, relnamespace, 
	   case when reltype > 10000 then 10000 else reltype end as reltype,
       relowner, relam, reltablespace, reltoastrelid, reltoastidxid, 
	   relaosegrelid, relaosegidxid, relhasindex, relisshared, relkind, 
	   relstorage, relnatts, relchecks, reltriggers, relukeys, relfkeys, 
	   relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, reloptions
from public.pg_class where oid < 10000 and relname !~ 'pg_toast'
except all
select relname, relnamespace, 
	   case when reltype > 10000 then 10000 else reltype end as reltype,
       relowner, relam, reltablespace, reltoastrelid, reltoastidxid, 
	   relaosegrelid, relaosegidxid, relhasindex, relisshared, relkind, 
	   relstorage, relnatts, relchecks, reltriggers, relukeys, relfkeys, 
	   relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, reloptions
from public.pg_class_v33 where oid < 10000 and relname !~ 'pg_toast';

-- compare old and new pg_type
select oid, * from public.pg_type_v33 where oid < 10000
except all
select oid, * from public.pg_type where oid < 10000;

select oid, * from public.pg_type where oid < 10000
except all
select oid, * from public.pg_type_v33 where oid < 10000;

-- compare old and new pg_aggregate
select * from public.pg_aggregate_v33 where aggfnoid::oid < 10000
except all
select * from public.pg_aggregate where aggfnoid::oid < 10000;

select * from public.pg_aggregate where aggfnoid::oid < 10000
except all
select * from public.pg_aggregate_v33 where aggfnoid::oid < 10000;

-- pg_namespace
select oid, nspname, nspowner from public.pg_namespace_v33 where oid < 10000
except all
select oid, nspname, nspowner from public.pg_namespace where oid < 10000;

select oid, nspname, nspowner from public.pg_namespace where oid < 10000 
except all
select oid, nspname, nspowner from public.pg_namespace_v33 where oid < 10000;

-- pg_conversion
select * from public.pg_conversion_v33
except all
select * from public.pg_conversion;

select * from public.pg_conversion
except all
select * from public.pg_conversion_v33;

-- pg_description
select * from public.pg_description_v33 where objoid < 10000
except all
select * from public.pg_description where objoid < 10000;

select * from public.pg_description where objoid < 10000
except all
select * from public.pg_description_v33 where objoid < 10000;

-- pg_depend
select * from public.pg_depend_v33 where objid < 10000 and refobjid < 10000
except all
select * from public.pg_depend where objid < 10000 and refobjid < 10000;

select * from public.pg_depend where objid < 10000 and refobjid < 10000
except all
select * from public.pg_depend_v33 where objid < 10000 and refobjid < 10000;

-- pg_shdescription
select * from public.pg_shdescription_v33 where objoid < 10000
except all
select * from public.pg_shdescription where objoid < 10000;

select * from public.pg_shdescription where objoid < 10000
except all
select * from public.pg_shdescription_v33 where objoid < 10000;

-- pg_shdepend
select * from public.pg_shdepend_v33 where objid < 10000 and refobjid < 10000
except all
select * from public.pg_shdepend where objid < 10000 and refobjid < 10000;

select * from public.pg_shdepend where objid < 10000 and refobjid < 10000
except all
select * from public.pg_shdepend_v33 where objid < 10000 and refobjid < 10000;

-- compare old and new pg_rewrite
--   We must take care to mask out OIDS that may not match between our catalog
--   versions (any oid >= 10000, so we simply mask out all occurances of 5+ digits).
--
-- NOTE:
--   pg_partitions diffs are caused by a harmless change in the way that window
--   functions are handled.   This diff will disapear after we upgarde to 34.
--
select 
  nspname, relname, rulename, ev_attr, ev_type, is_instead,
  regexp_replace(ev_qual || ev_action, '[1-9][0-9][0-9][0-9][0-9]+', 'xxxxx', 'g') as compiled
from public.pg_rewrite 
     join public.pg_class c on (c.oid = ev_class)
     join public.pg_namespace n on (n.oid = c.relnamespace)
where nspname in ('pg_catalog', 'information_schema')
except all
select 
  nspname, relname, rulename, ev_attr, ev_type, is_instead,
  regexp_replace(ev_qual || ev_action, '[1-9][0-9][0-9][0-9][0-9]+', 'xxxxx', 'g') as compiled
from public.pg_rewrite_v33 
     join public.pg_class_v33 c on (c.oid = ev_class)
     join public.pg_namespace_v33 n on (n.oid = c.relnamespace)
where nspname in ('pg_catalog', 'information_schema');

select 
  nspname, relname, rulename, ev_attr, ev_type, is_instead,
  regexp_replace(ev_qual || ev_action, '[1-9][0-9][0-9][0-9][0-9]+', 'xxxxx', 'g') as compiled
from public.pg_rewrite_v33 
     join public.pg_class_v33 c on (c.oid = ev_class)
     join public.pg_namespace_v33 n on (n.oid = c.relnamespace)
where nspname in ('pg_catalog', 'information_schema')
except all
select 
  nspname, relname, rulename, ev_attr, ev_type, is_instead,
  regexp_replace(ev_qual || ev_action, '[1-9][0-9][0-9][0-9][0-9]+', 'xxxxx', 'g') as compiled
from public.pg_rewrite 
     join public.pg_class c on (c.oid = ev_class)
     join public.pg_namespace n on (n.oid = c.relnamespace)
where nspname in ('pg_catalog', 'information_schema');

-- compare old and new pg_appendonly
select * from public.pg_appendonly where relid < 10000;

select * from public.pg_appendonly_v33 where relid < 10000;

-- compare old and new pg_exttable
select * from public.pg_exttable where reloid < 10000;

select * from public.pg_exttable_v33 where reloid < 10000;

-- compare old and new pg_resqueue
select * from public.pg_resqueue where oid < 10000;

select * from public.pg_resqueue_v33 where oid < 10000;

-- compare old and new pg_cast
select * from public.pg_cast
except all
select * from public.pg_cast_v33;

select * from public.pg_cast_v33
except all
select * from public.pg_cast;

-- pg_opclass
select * from public.pg_opclass
except all
select * from public.pg_opclass_v33;

select * from public.pg_opclass_v33
except all
select * from public.pg_opclass;

-- pg_amproc
select * from public.pg_amproc
except all
select * from public.pg_amproc_v33;

select * from public.pg_amproc_v33
except all
select * from public.pg_amproc;

-- pg_amop
select * from public.pg_amop
except all
select * from public.pg_amop_v33;

select * from public.pg_amop_v33
except all
select * from public.pg_amop;

-- 
-- Some manual fixups.
--   The loadcat below will added some colums to our "public" versions of the
--   catalogs, but this updated the "public.pg_attribute".  Perform the logical
--   operations on the real object so that the columns actually exist when we
--   try to manipulate the table in loadcat.sh
--
-- WARNING: DO NOT ADD ACTUAL CATALOG UPGRADE LOGIC HERE!
alter table public.pg_exttable add column writable boolean;


--
-- 7. Run the scripts that upgrade from 33->34
--      phase 1:  loadcat34
--      phase 2:  loadcat34_sh
--
\i @abs_srcdir@/sql/loadcat34.sql

-- We updated the public.pg_attribute manually, but since we will
-- be doing data operations we need to update in the real catalag too...
alter table public.pg_tablespace add column spcfsoid oid;

\i @abs_srcdir@/sql/loadcat34_sh.sql

-- 
-- Some manual fixups.
--   The above loadcat added some columns to our "public" versions of the
--   catalogs, but this updated the "pg_catalog.pg_attribute".
--   Insert the appropriate rows into the "public.pg_attribute".
--
-- WARNING: DO NOT ADD ACTUAL CATALOG UPGRADE LOGIC HERE!
--
-- This is only to fix the dummy catalog for Alter operations.  When these
-- are run by the loadcat script the tables are only updated in the Real
-- catalog and we must manually update the dummy catalog to account for them.
--
insert into public.pg_attribute 
  select 'pg_catalog.pg_appendonly'::regclass, a.attname, a.atttypid,
    a.attstattarget, a.attlen, a.attnum, a.attndims, a.attcacheoff,
    a.atttypmod, a.attbyval, a.attstorage, a.attalign, a.attnotnull,
    a.atthasdef, a.attisdropped, a.attislocal, a.attinhcount
  from pg_catalog.pg_attribute a
  where (attrelid, attnum) in ( values('public.pg_appendonly'::regclass, 9),
							          ('public.pg_appendonly'::regclass, 10),
							 		  ('public.pg_appendonly'::regclass, 11),
							 		  ('public.pg_appendonly'::regclass, 12),
							 		  ('public.pg_appendonly'::regclass, 13),
							 		  ('public.pg_appendonly'::regclass, 14));
update public.pg_class set relnatts=14 where oid = 'pg_catalog.pg_appendonly'::regclass;

-- System views that have changed, update fake schema.
--   We upgrade "public.viewname", which is a view defined in the _actual_
--   catalog, we need to mirror these updates in the fake schema so that
--   we can diff the fake schema to the real views ("pg_catalog.viewname")
update public.pg_rewrite av set ev_action = bv.ev_action
from public.pg_class ac,
     public.pg_namespace an, 
	 pg_catalog.pg_rewrite bv, 
	 pg_catalog.pg_class bc,
	 pg_catalog.pg_namespace bn
where ac.oid = av.ev_class     
  and bc.oid = bv.ev_class 
  and ac.relnamespace = an.oid
  and bc.relnamespace = bn.oid
  and an.nspname in ('information_schema', 'pg_catalog')
  and bn.nspname in ('public')
  and ac.relname=bc.relname
  and bc.oid in (
     'public.check_constraints'::regclass,
     'public.element_types'::regclass,
     'public.parameters'::regclass,
     'public.role_usage_grants'::regclass,
     'public.table_constraints'::regclass,
     'public.usage_privileges'::regclass,
     'public.views'::regclass,
	 'public.pg_partitions'::regclass,
	 'public.pg_partition_templates'::regclass,
	 'public.tables'::regclass
  );

-- System views that are new
insert into public.pg_rewrite
  select * from pg_catalog.pg_rewrite
  where ev_class in (
     'public._pg_foreign_data_wrappers'::regclass,
	 'public.foreign_data_wrapper_options'::regclass,
	 'public.foreign_data_wrappers'::regclass,
	 'public._pg_foreign_servers'::regclass,
	 'public.foreign_server_options'::regclass,
	 'public.foreign_servers'::regclass,
	 'public._pg_user_mappings'::regclass,
	 'public.user_mapping_options'::regclass,
	 'public.user_mappings'::regclass,
	 'public.pg_user_mappings'::regclass,
	 'public.pg_stat_operations'::regclass,
	 'public.pg_stat_partition_operations'::regclass,
	 'public.pg_resqueue_attributes'::regclass
  );
-- add views created in pg_catalog to public.pg_class
copy ( 
  select oid, relname, (select oid from public.pg_namespace where nspname='pg_catalog'),
	 	 reltype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, 
 		 reltoastrelid, reltoastidxid, relaosegrelid, relaosegidxid, relhasindex,
		 relisshared, relkind, relstorage, relnatts, relchecks, reltriggers, 
		 relukeys, relfkeys, relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, 
		 relfrozenxid, relacl, reloptions
  from pg_catalog.pg_class
  where oid in (
	 'public.pg_user_mappings'::regclass,
	 'public.pg_stat_operations'::regclass,
	 'public.pg_stat_partition_operations'::regclass,
	 'public.pg_resqueue_attributes'::regclass
)) to '/tmp/pg_class';
copy public.pg_class from '/tmp/pg_class' with oids;
-- add views created in information_schema to public.pg_class
copy (
  select oid, relname, (select oid from public.pg_namespace where nspname='information_schema'),
	 	 reltype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, 
 		 reltoastrelid, reltoastidxid, relaosegrelid, relaosegidxid, relhasindex,
		 relisshared, relkind, relstorage, relnatts, relchecks, reltriggers, 
		 relukeys, relfkeys, relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, 
		 relfrozenxid, relacl, reloptions
  from pg_catalog.pg_class
  where oid in (
     'public._pg_foreign_data_wrappers'::regclass,
	 'public.foreign_data_wrapper_options'::regclass,
	 'public.foreign_data_wrappers'::regclass,
	 'public._pg_foreign_servers'::regclass,
	 'public.foreign_server_options'::regclass,
	 'public.foreign_servers'::regclass,
	 'public._pg_user_mappings'::regclass,
	 'public.user_mapping_options'::regclass,
	 'public.user_mappings'::regclass
)) to '/tmp/pg_class';
copy public.pg_class from '/tmp/pg_class' with oids;

--
-- 8. Compare upgraded 33 to actual 34
--

-- new pg_partitions 
--   note that the view changed, pg_catalog.pg_partitions should now
--   be the same as public.pg_partitions
--
select pg_get_viewdef(a.ev_class) = pg_get_viewdef(b.ev_class)
from pg_rewrite a, pg_rewrite b
where
a.ev_class = 'public.pg_partitions'::regclass and
b.ev_class = 'pg_catalog.pg_partitions'::regclass;


-- new pg_roles 
--   note that the view changed, pg_catalog.pg_roles should now
--   be the same as public.pg_roles
--
select pg_get_viewdef(a.ev_class) = pg_get_viewdef(b.ev_class)
from pg_rewrite a, pg_rewrite b
where
a.ev_class = 'public.pg_roles'::regclass and
b.ev_class = 'pg_catalog.pg_roles'::regclass;

-- pg_attribute 
select c.relname, a.attname, a.attnum, t.typname, 
	   a.attlen, a.attndims, a.attcacheoff, a.atttypmod, a.attbyval, 
	   a.attstorage, a.attalign, a.attnotnull, a.atthasdef, a.attisdropped,
	   a.attislocal, a.attinhcount
from public.pg_attribute a
     left join public.pg_class c on (c.oid = a.attrelid)
     left join public.pg_type t on (t.oid = a.atttypid)
     where a.attrelid < 10000
except all
select c.relname, a.attname, a.attnum, t.typname, 
	   a.attlen, a.attndims, a.attcacheoff, a.atttypmod, a.attbyval, 
	   a.attstorage, a.attalign, a.attnotnull, a.atthasdef, a.attisdropped,
	   a.attislocal, a.attinhcount
from pg_catalog.pg_attribute a
     left join pg_catalog.pg_class c on (c.oid = a.attrelid)
     left join pg_catalog.pg_type t on (t.oid = a.atttypid)
     where a.attrelid < 10000;

select c.relname, a.attname, a.attnum, t.typname, 
	   a.attlen, a.attndims, a.attcacheoff, a.atttypmod, a.attbyval, 
	   a.attstorage, a.attalign, a.attnotnull, a.atthasdef, a.attisdropped,
	   a.attislocal, a.attinhcount
from pg_catalog.pg_attribute a
     left join pg_catalog.pg_class c on (c.oid = a.attrelid)
     left join pg_catalog.pg_type t on (t.oid = a.atttypid)
     where a.attrelid < 10000
except all
select c.relname, a.attname, a.attnum, t.typname, 
	   a.attlen, a.attndims, a.attcacheoff, a.atttypmod, a.attbyval, 
	   a.attstorage, a.attalign, a.attnotnull, a.atthasdef, a.attisdropped,
	   a.attislocal, a.attinhcount
from public.pg_attribute a
     left join public.pg_class c on (c.oid = a.attrelid)
     left join public.pg_type t on (t.oid = a.atttypid)
     where a.attrelid < 10000;

-- compare old and new pg_index
select * from pg_catalog.pg_index where indexrelid < 10000
except all
select * from public.pg_index where indexrelid < 10000;

select * from public.pg_index where indexrelid < 10000
except all
select * from pg_catalog.pg_index where indexrelid < 10000;

-- compare old and new pg_proc (all columns except acl which has sort issues)
select proname, pronamespace, proowner, prolang, proisagg, prosecdef,
       proisstrict, proretset, provolatile, pronargs, prorettype,
       proiswin, proargtypes, proallargtypes, proargmodes, proargnames,
       prosrc, probin
from pg_catalog.pg_proc where oid < 10000
except all
select proname, pronamespace, proowner, prolang, proisagg, prosecdef,
       proisstrict, proretset, provolatile, pronargs, prorettype,
       proiswin, proargtypes, proallargtypes, proargmodes, proargnames,
       prosrc, probin
from public.pg_proc where oid < 10000;

select proname, pronamespace, proowner, prolang, proisagg, prosecdef,
       proisstrict, proretset, provolatile, pronargs, prorettype,
       proiswin, proargtypes, proallargtypes, proargmodes, proargnames,
       prosrc, probin
from public.pg_proc where oid < 10000
except all
select proname, pronamespace, proowner, prolang, proisagg, prosecdef,
       proisstrict, proretset, provolatile, pronargs, prorettype,
       proiswin, proargtypes, proallargtypes, proargmodes, proargnames,
       prosrc, probin
from pg_catalog.pg_proc where oid < 10000;

-- compare old and new pg_operator
select * from pg_catalog.pg_operator where oid < 10000
except all
select * from public.pg_operator where oid < 10000;

select * from public.pg_operator where oid < 10000
except all
select * from pg_catalog.pg_operator where oid < 10000;

-- compare old and new pg_class
select relname, relnamespace, 
	   case when reltype > 10000 then 10000 else reltype end as reltype,
       relowner, relam, reltablespace, reltoastrelid, reltoastidxid, 
	   relaosegrelid, relaosegidxid, relhasindex, relisshared, relkind, 
	   relstorage, relnatts, relchecks, reltriggers, relukeys, relfkeys, 
	   relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, reloptions
from pg_catalog.pg_class where oid < 10000 and relname !~ 'pg_toast'
except all
select relname, relnamespace, 
	   case when reltype > 10000 then 10000 else reltype end as reltype,
       relowner, relam, reltablespace, reltoastrelid, reltoastidxid, 
	   relaosegrelid, relaosegidxid, relhasindex, relisshared, relkind, 
	   relstorage, relnatts, relchecks, reltriggers, relukeys, relfkeys, 
	   relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, reloptions
from public.pg_class where oid < 10000 and relname !~ 'pg_toast';

select relname, relnamespace, 
	   case when reltype > 10000 then 10000 else reltype end as reltype,
       relowner, relam, reltablespace, reltoastrelid, reltoastidxid, 
	   relaosegrelid, relaosegidxid, relhasindex, relisshared, relkind, 
	   relstorage, relnatts, relchecks, reltriggers, relukeys, relfkeys, 
	   relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, reloptions
from public.pg_class where oid < 10000 and relname !~ 'pg_toast'
except all
select relname, relnamespace, 
	   case when reltype > 10000 then 10000 else reltype end as reltype,
       relowner, relam, reltablespace, reltoastrelid, reltoastidxid, 
	   relaosegrelid, relaosegidxid, relhasindex, relisshared, relkind, 
	   relstorage, relnatts, relchecks, reltriggers, relukeys, relfkeys, 
	   relrefs, relhasoids, relhaspkey, relhasrules, relhassubclass, reloptions
from pg_catalog.pg_class where oid < 10000 and relname !~ 'pg_toast';

-- compare old and new pg_type
select oid, * from pg_catalog.pg_type where oid < 10000
except all
select oid, * from public.pg_type where oid < 10000;

select oid, * from public.pg_type where oid < 10000
except all
select oid, * from pg_catalog.pg_type where oid < 10000;

-- compare old and new pg_aggregate
select * from pg_catalog.pg_aggregate where aggfnoid::oid < 10000
except all
select * from public.pg_aggregate where aggfnoid::oid < 10000;

select * from public.pg_aggregate where aggfnoid::oid < 10000
except all
select * from pg_catalog.pg_aggregate where aggfnoid::oid < 10000;

-- pg_namespace
select oid, nspname, nspowner from pg_catalog.pg_namespace where oid < 10000
except all
select oid, nspname, nspowner from public.pg_namespace where oid < 10000;

select oid, nspname, nspowner from public.pg_namespace where oid < 10000 
except all
select oid, nspname, nspowner from pg_catalog.pg_namespace where oid < 10000;

-- pg_conversion
select * from pg_catalog.pg_conversion
except all
select * from public.pg_conversion;

select * from public.pg_conversion
except all
select * from pg_catalog.pg_conversion;

-- pg_description
select * from pg_catalog.pg_description where objoid < 10000
except all
select * from public.pg_description where objoid < 10000;

select * from public.pg_description where objoid < 10000
except all
select * from pg_catalog.pg_description where objoid < 10000;

-- pg_depend
select * from pg_catalog.pg_depend where objid < 10000 and refobjid < 10000
except all
select * from public.pg_depend where objid < 10000 and refobjid < 10000;

select * from public.pg_depend where objid < 10000 and refobjid < 10000
except all
select * from pg_catalog.pg_depend where objid < 10000 and refobjid < 10000;

-- pg_shdescription
select * from pg_catalog.pg_shdescription where objoid < 10000
except all
select * from public.pg_shdescription where objoid < 10000;

select * from public.pg_shdescription where objoid < 10000
except all
select * from pg_catalog.pg_shdescription where objoid < 10000;

-- pg_shdepend
select * from pg_catalog.pg_shdepend where objid < 10000 and refobjid < 10000
except all
select * from public.pg_shdepend where objid < 10000 and refobjid < 10000;

select * from public.pg_shdepend where objid < 10000 and refobjid < 10000
except all
select * from pg_catalog.pg_shdepend where objid < 10000 and refobjid < 10000;

-- compare old and new pg_rewrite
--   We must take care to mask out OIDS that may not match between our catalog
--   versions (any oid >= 10000, so we simply mask out all occurances of 5+ digits).
--
-- Note: the diff in those relations is due to pg_tablespace and pg_authid having an
-- extra column that is not actually referenced in the views.  This is a typical
-- difference you see in otherwise identical views when underlying tables have
-- added columns through normal operations and is harmless.
--
select 
  nspname, relname, rulename, ev_attr, ev_type, is_instead,
  regexp_replace(ev_qual || ev_action, '[1-9][0-9][0-9][0-9][0-9]+', 'xxxxx', 'g') as compiled
from public.pg_rewrite
     join public.pg_class c on (c.oid = ev_class)
     join public.pg_namespace n on (n.oid = c.relnamespace)
where nspname in ('pg_catalog', 'information_schema')
except all
select 
  nspname, relname, rulename, ev_attr, ev_type, is_instead,
  regexp_replace(ev_qual || ev_action, '[1-9][0-9][0-9][0-9][0-9]+', 'xxxxx', 'g') as compiled
from pg_catalog.pg_rewrite
     join pg_catalog.pg_class c on (c.oid = ev_class)
     join pg_catalog.pg_namespace n on (n.oid = c.relnamespace)
where nspname in ('pg_catalog', 'information_schema');

select 
  nspname, relname, rulename, ev_attr, ev_type, is_instead,
  regexp_replace(ev_qual || ev_action, '[1-9][0-9][0-9][0-9][0-9]+', 'xxxxx', 'g') as compiled
from pg_catalog.pg_rewrite
     join pg_catalog.pg_class c on (c.oid = ev_class)
     join pg_catalog.pg_namespace n on (n.oid = c.relnamespace)
where nspname in ('pg_catalog', 'information_schema')
except all
select 
  nspname, relname, rulename, ev_attr, ev_type, is_instead,
  regexp_replace(ev_qual || ev_action, '[1-9][0-9][0-9][0-9][0-9]+', 'xxxxx', 'g') as compiled
from public.pg_rewrite
     join public.pg_class c on (c.oid = ev_class)
     join public.pg_namespace n on (n.oid = c.relnamespace)
where nspname in ('pg_catalog', 'information_schema');

-- compare old and new pg_appendonly
select relid from public.pg_appendonly where relid < 10000;

select relid from pg_catalog.pg_appendonly where relid < 10000;

-- compare old and new pg_exttable
select * from public.pg_exttable where reloid < 10000;

select * from pg_catalog.pg_exttable where reloid < 10000;

-- compare old and new pg_resqueue
select * from pg_catalog.pg_resqueue where oid < 10000
except all
select * from public.pg_resqueue where oid < 10000;

select * from public.pg_resqueue where oid < 10000
except all
select * from pg_catalog.pg_resqueue where oid < 10000;

-- compare old and new pg_resourcetype
select * from pg_catalog.pg_resourcetype where oid < 10000
except all
select * from public.pg_resourcetype where oid < 10000;

select * from public.pg_resourcetype where oid < 10000
except all
select * from pg_catalog.pg_resourcetype where oid < 10000;

-- compare old and new pg_cast
select * from pg_catalog.pg_cast
except all
select * from public.pg_cast;

select * from public.pg_cast
except all
select * from pg_catalog.pg_cast;

-- pg_opclass
select * from pg_catalog.pg_opclass
except all
select * from public.pg_opclass;

select * from public.pg_opclass
except all
select * from pg_catalog.pg_opclass;

-- pg_amproc
select * from pg_catalog.pg_amproc
except all
select * from public.pg_amproc;

select * from public.pg_amproc
except all
select * from pg_catalog.pg_amproc;

-- pg_amop
select * from pg_catalog.pg_amop
except all
select * from public.pg_amop;

select * from public.pg_amop
except all
select * from pg_catalog.pg_amop;

-- pg_tablespace
select oid, spcname, spcowner, spcfsoid from pg_catalog.pg_tablespace where oid < 10000
except all
select oid, spcname, spcowner, spcfsoid from public.pg_tablespace where oid < 10000;

select oid, spcname, spcowner, spcfsoid from public.pg_tablespace where oid < 10000
except all
select oid, spcname, spcowner, spcfsoid from pg_catalog.pg_tablespace where oid < 10000;

-- gp_fault_strategy
select fault_strategy from public.gp_fault_strategy
except all
select fault_strategy from pg_catalog.gp_fault_strategy;

select fault_strategy from pg_catalog.gp_fault_strategy
except all
select fault_strategy from public.gp_fault_strategy;

--
-- 9. Final sanity checks and cleanup
--

-- Check for duplicate oids
SELECT oid, count(*)
FROM (          SELECT oid FROM pg_catalog.pg_authid
      UNION ALL SELECT oid FROM pg_catalog.pg_type
      UNION ALL SELECT oid FROM pg_catalog.pg_proc
      UNION ALL SELECT oid FROM pg_catalog.pg_class
      UNION ALL SELECT oid FROM pg_catalog.pg_attrdef
      UNION ALL SELECT oid FROM pg_catalog.pg_constraint
      UNION ALL SELECT oid FROM pg_catalog.pg_operator
      UNION ALL SELECT oid FROM pg_catalog.pg_opclass
      UNION ALL SELECT oid FROM pg_catalog.pg_am
      UNION ALL SELECT oid FROM pg_catalog.pg_language
      UNION ALL SELECT oid FROM pg_catalog.pg_rewrite
      UNION ALL SELECT oid FROM pg_catalog.pg_trigger
      UNION ALL SELECT oid FROM pg_catalog.pg_cast
      UNION ALL SELECT oid FROM pg_catalog.pg_namespace
      UNION ALL SELECT oid FROM pg_catalog.pg_conversion
      UNION ALL SELECT oid FROM pg_catalog.pg_tablespace
      UNION ALL SELECT oid FROM pg_catalog.pg_resqueue
      UNION ALL SELECT oid FROM pg_catalog.pg_resourcetype
      UNION ALL SELECT oid FROM pg_catalog.pg_partition
      UNION ALL SELECT oid FROM pg_catalog.pg_partition_rule
      UNION ALL SELECT oid FROM pg_catalog.pg_database
     ) oid_tables
GROUP BY oid
HAVING count(*) > 1;

drop table
  public.pg_class,
  public.pg_attribute,
  public.pg_type,
  public.pg_index,
  public.pg_aggregate,
  public.pg_proc,
  public.pg_operator,
  public.pg_namespace,
  public.pg_conversion,
  public.pg_description,
  public.pg_depend,
  public.pg_shdescription,
  public.pg_shdepend,
  public.pg_rewrite,
  public.pg_cast,
  public.pg_opclass,
  public.pg_amproc,
  public.pg_amop,
  public.pg_authid,
  public.pg_resqueue,
  public.pg_class_v33,
  public.pg_attribute_v33,
  public.pg_type_v33,
  public.pg_index_v33,
  public.pg_aggregate_v33,
  public.pg_proc_v33,
  public.pg_operator_v33,
  public.pg_namespace_v33,
  public.pg_conversion_v33,
  public.pg_description_v33,
  public.pg_depend_v33,
  public.pg_shdescription_v33,
  public.pg_shdepend_v33,
  public.pg_rewrite_v33,
  public.pg_cast_v33,
  public.pg_opclass_v33,
  public.pg_amproc_v33,
  public.pg_amop_v33,
  public.pg_appendonly,
  public.pg_appendonly_v33,
  public.pg_exttable,
  public.pg_exttable_v33,
  public.pg_authid_v33,
  public.pg_resqueue_v33,
  public.gp_configuration_history,
  public.gp_db_interfaces,
  public.gp_interfaces,
  public.pg_filespace,
  public.pg_tablespace,
  public.pg_stat_last_operation,
  public.gp_san_configuration,
  public.gp_segment_configuration,
  public.gp_fault_strategy,
  public.pg_appendonly_alter_column,
  public.pg_filespace_entry,
  public.pg_foreign_data_wrapper,
  public.pg_foreign_server,
  public.pg_user_mapping,
  public.pg_resourcetype,
  public.pg_resqueuecapability,
  public.pg_stat_last_shoperation,
  public.gp_fastsequence,
  public.gp_distribution_policy;
drop view
   public.pg_partitions,
   public.pg_partitions_v33,
   public._pg_foreign_data_wrappers,
   public._pg_foreign_servers,
   public.pg_user_mappings
CASCADE;
